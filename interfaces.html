<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<title>fnpcell.interfaces API documentation</title>
<meta name="description" content="Common interfaces and value types for fnpcell" />
<link rel="preload stylesheet" as="style" href="assets/10up-sanitize.css/11.0.1/sanitize.min.css">
<link rel="preload stylesheet" as="style" href="assets/10up-sanitize.css/11.0.1/typography.min.css">
<link rel="stylesheet preload" as="style" href="assets/highlight.js/10.1.1/styles/github-dark.min.css">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="assets/highlight.js/10.1.1/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fnpcell.interfaces</code></h1>
</header>
<section id="section-intro">
<p>Common interfaces and value types for fnpcell</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fnpcell.interfaces.Waypoint"><code class="name flex">
<span>def <span class="ident">Waypoint</span></span>(<span>x: float, y: float, a: float) ‑> <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a Waypoint.</p>
<p>x,y is location.
a is angle in degrees.</p></div>
</dd>
<dt id="fnpcell.interfaces.angle_between"><code class="name flex">
<span>def <span class="ident">angle_between</span></span>(<span>point: Tuple[float, float], origin: Tuple[float, float] = (0, 0)) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Return angle in radians</p></div>
</dd>
<dt id="fnpcell.interfaces.cache"><code class="name flex">
<span>def <span class="ident">cache</span></span>(<span>) ‑> Callable[[~_Fn], ~_Fn]</span>
</code></dt>
<dd>
<div class="desc"><p>Used as cache decorator.</p>
<p>Arguments to the cached function must be hashable.</p></div>
</dd>
<dt id="fnpcell.interfaces.clamp"><code class="name flex">
<span>def <span class="ident">clamp</span></span>(<span>value: float, min: float, max: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Return value ∈[min, max].</p></div>
</dd>
<dt id="fnpcell.interfaces.distance_between"><code class="name flex">
<span>def <span class="ident">distance_between</span></span>(<span>point: Tuple[float, float], origin: Tuple[float, float] = (0, 0)) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Return distance between point and origin.</p></div>
</dd>
<dt id="fnpcell.interfaces.is_abstract"><code class="name flex">
<span>def <span class="ident">is_abstract</span></span>(<span>cls: Type[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Determine whether cls is a abstract class.</p></div>
</dd>
<dt id="fnpcell.interfaces.is_dataclass"><code class="name flex">
<span>def <span class="ident">is_dataclass</span></span>(<span>cls: Type[Any]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.midpoint_of"><code class="name flex">
<span>def <span class="ident">midpoint_of</span></span>(<span>point: Tuple[float, float], origin: Tuple[float, float] = (0, 0)) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Return middle point of point and origin.</p></div>
</dd>
<dt id="fnpcell.interfaces.normalize_angle"><code class="name flex">
<span>def <span class="ident">normalize_angle</span></span>(<span>angle: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Return angle ∈[-math.pi, math.pi].</p></div>
</dd>
<dt id="fnpcell.interfaces.transform_between"><code class="name flex">
<span>def <span class="ident">transform_between</span></span>(<span>device: <a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a>, host: <a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a>) ‑> <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return transform from device to host.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fnpcell.interfaces.Absolute"><code class="flex name class">
<span>class <span class="ident">Absolute</span></span>
<span>(</span><span>value: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Absolute(value: float)</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Absolute.value"><code class="name">var <span class="ident">value</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Anchor"><code class="flex name class">
<span>class <span class="ident">Anchor</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign where the (0, 0) is.</p>
<h2 id="usage">Usage</h2>
<p>from fnpcell import all as fp
Straight(name="", anchor=fp.Anchor.CENTER, &hellip;)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Anchor.CENTER"><code class="name">var <span class="ident">CENTER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Anchor.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Anchor.START"><code class="name">var <span class="ident">START</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.FrozenDict"><code class="flex name class">
<span>class <span class="ident">FrozenDict</span></span>
<span>(</span><span>*args: Any, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>An immutable dict which supports hashing</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fnpcell.interfaces.FrozenDict.freeze"><code class="name flex">
<span>def <span class="ident">freeze</span></span>(<span>value: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.FrozenDict.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key: ~_K, default: Optional[~_V] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>D.get(k[,d]) -&gt; D[k] if k in D, else d.
d defaults to None.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Glyph"><code class="flex name class">
<span>class <span class="ident">Glyph</span></span>
<span>(</span><span>advance_width: float, left_side_bearing: float, right_side_bearing: float, bounding_box: Tuple[Tuple[float, float], Tuple[float, float]], highlight_box: Tuple[Tuple[float, float], Tuple[float, float]], paths: Tuple[Tuple[Union[Tuple[Literal['Z']], Tuple[Literal['L', 'M'], Tuple[float, float]], Tuple[Literal['Q'], Tuple[float, float], Tuple[float, float]], Tuple[Literal['C'], Tuple[float, float], Tuple[float, float], Tuple[float, float]]], ...], ...])</span>
</code></dt>
<dd>
<div class="desc"><p>Glyph(advance_width: float, left_side_bearing: float, right_side_bearing: float, bounding_box: Tuple[Tuple[float, float], Tuple[float, float]], highlight_box: Tuple[Tuple[float, float], Tuple[float, float]], paths: Tuple[Tuple[Union[Tuple[Literal['Z']], Tuple[Literal['L', 'M'], Tuple[float, float]], Tuple[Literal['Q'], Tuple[float, float], Tuple[float, float]], Tuple[Literal['C'], Tuple[float, float], Tuple[float, float], Tuple[float, float]]], &hellip;], &hellip;])</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Glyph.advance_width"><code class="name">var <span class="ident">advance_width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Glyph.bounding_box"><code class="name">var <span class="ident">bounding_box</span> : Tuple[Tuple[float, float], Tuple[float, float]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Glyph.highlight_box"><code class="name">var <span class="ident">highlight_box</span> : Tuple[Tuple[float, float], Tuple[float, float]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Glyph.left_side_bearing"><code class="name">var <span class="ident">left_side_bearing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Glyph.paths"><code class="name">var <span class="ident">paths</span> : Tuple[Tuple[Union[Tuple[Literal['Z']], Tuple[Literal['L', 'M'], Tuple[float, float]], Tuple[Literal['Q'], Tuple[float, float], Tuple[float, float]], Tuple[Literal['C'], Tuple[float, float], Tuple[float, float], Tuple[float, float]]], ...], ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Glyph.right_side_bearing"><code class="name">var <span class="ident">right_side_bearing</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Hidden"><code class="flex name class">
<span>class <span class="ident">Hidden</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Hidden(name: str)</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Hidden.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable"><code class="flex name class">
<span>class <span class="ident">IAffineTransformable</span></span>
</code></dt>
<dd>
<div class="desc"><p>IAffineTransformable supports transform, can be scaled, rotated, translated, h_mirrored, v_mirrored, c_mirrored.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRegion" href="#fnpcell.interfaces.IRegion">IRegion</a></li>
<li><a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a></li>
<li><a title="fnpcell.mixin.transform_mixin.TransformMixin" href="mixin/transform_mixin.html#fnpcell.mixin.transform_mixin.TransformMixin">TransformMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IAffineTransformable.transform"><code class="name">var <span class="ident">transform</span> : <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IAffineTransformable.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used.</p>
<p>Rotation origin can be provided too.</p></div>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable.transform_combined"><code class="name flex">
<span>def <span class="ident">transform_combined</span></span>(<span>self: ~_Self, transform: <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a>) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IAffineTransformable.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IAutoVias"><code class="flex name class">
<span>class <span class="ident">IAutoVias</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.auto_vias.AutoVias" href="pdk/technology/auto_vias.html#fnpcell.pdk.technology.auto_vias.AutoVias">AutoVias</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.IBand"><code class="flex name class">
<span>class <span class="ident">IBand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of Band type.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.bands.Band" href="pdk/technology/bands.html#fnpcell.pdk.technology.bands.Band">Band</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IBand.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IBendCurveFactory"><code class="flex name class">
<span>class <span class="ident">IBendCurveFactory</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="fnpcell.interfaces.IBendWaveguideFactory"><code class="flex name class">
<span>class <span class="ident">IBendWaveguideFactory</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="fnpcell.interfaces.ICell"><code class="flex name class">
<span>class <span class="ident">ICell</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of containers.
An IRunnableContainer runs processors to process itself and its content.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRunnableContainer" href="#fnpcell.interfaces.IRunnableContainer">IRunnableContainer</a></li>
<li>typing.Generic</li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fnpcell.cell.cell._CellMixin</li>
<li>fnpcell.cell.cell._PatchedCell</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICell.bands"><code class="name">var <span class="ident">bands</span> : Optional[FrozenSet[<a title="fnpcell.interfaces.IBand" href="#fnpcell.interfaces.IBand">IBand</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.content"><code class="name">var <span class="ident">content</span> : Tuple[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.name"><code class="name">var <span class="ident">name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.ports"><code class="name">var <span class="ident">ports</span> : Tuple[<a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICell.new_array"><code class="name flex">
<span>def <span class="ident">new_array</span></span>(<span>self, *, cols: int = 1, col_width: float = 0, rows: int = 1, row_height: float = 0, transform: <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a> = Affine2D.identity()) ‑> <a title="fnpcell.interfaces.ICellArray" href="#fnpcell.interfaces.ICellArray">ICellArray</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.new_ref"><code class="name flex">
<span>def <span class="ident">new_ref</span></span>(<span>self, transform: <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a> = Affine2D.identity()) ‑> <a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.polygon_set"><code class="name flex">
<span>def <span class="ident">polygon_set</span></span>(<span>self, *, layer: <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>, union: bool = True) ‑> <a title="fnpcell.interfaces.IPolygonSet" href="#fnpcell.interfaces.IPolygonSet">IPolygonSet</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.with_bands"><code class="name flex">
<span>def <span class="ident">with_bands</span></span>(<span>self: ~_Self, bands: Optional[Iterable[<a title="fnpcell.interfaces.IBand" href="#fnpcell.interfaces.IBand">IBand</a>]]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.with_content"><code class="name flex">
<span>def <span class="ident">with_content</span></span>(<span>self: ~_Self, content: Iterable[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.with_name"><code class="name flex">
<span>def <span class="ident">with_name</span></span>(<span>self: ~_Self, name: str) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.with_patches"><code class="name flex">
<span>def <span class="ident">with_patches</span></span>(<span>self: ~_Self, content: Iterable[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICell.with_ports"><code class="name flex">
<span>def <span class="ident">with_ports</span></span>(<span>self: ~_Self, ports: Sequence[Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>]]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICellArray"><code class="flex name class">
<span>class <span class="ident">ICellArray</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.cell_array.CellArray" href="cell/cell_array.html#fnpcell.cell.cell_array.CellArray">CellArray</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICellArray.cell"><code class="name">var <span class="ident">cell</span> : <a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.col_end"><code class="name">var <span class="ident">col_end</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.cols"><code class="name">var <span class="ident">cols</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.row_end"><code class="name">var <span class="ident">row_end</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.rows"><code class="name">var <span class="ident">rows</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.transform"><code class="name">var <span class="ident">transform</span> : <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICellArray.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.c_mirrored" href="#fnpcell.interfaces.IElement.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>self) ‑> Tuple[<a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a>, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.h_mirrored" href="#fnpcell.interfaces.IElement.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.polygon_set"><code class="name flex">
<span>def <span class="ident">polygon_set</span></span>(<span>self, *, layer: <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>, union: bool = True) ‑> <a title="fnpcell.interfaces.IPolygonSet" href="#fnpcell.interfaces.IPolygonSet">IPolygonSet</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.rotated" href="#fnpcell.interfaces.IElement.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.scaled" href="#fnpcell.interfaces.IElement.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.translated" href="#fnpcell.interfaces.IElement.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellArray.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.v_mirrored" href="#fnpcell.interfaces.IElement.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICellRef"><code class="flex name class">
<span>class <span class="ident">ICellRef</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.cell_ref.CellRef" href="cell/cell_ref.html#fnpcell.cell.cell_ref.CellRef">CellRef</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li>fnpcell.pdk.pcell_runtime._Proxy</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICellRef.cell"><code class="name">var <span class="ident">cell</span> : <a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.transform"><code class="name">var <span class="ident">transform</span> : <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICellRef.ports"><code class="name">var <span class="ident">ports</span> : Tuple[<a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICellRef.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.c_mirrored" href="#fnpcell.interfaces.IElement.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.content_merged"><code class="name flex">
<span>def <span class="ident">content_merged</span></span>(<span>self: ~_Self, *, affected_layer: Iterable[<a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self, depth: int = 1) ‑> <a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.frozen"><code class="name flex">
<span>def <span class="ident">frozen</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.h_mirrored" href="#fnpcell.interfaces.IElement.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.new_array"><code class="name flex">
<span>def <span class="ident">new_array</span></span>(<span>self, *, cols: int = 1, col_width: float = 0, rows: int = 1, row_height: float = 0, transform: <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a> = Affine2D.identity()) ‑> <a title="fnpcell.interfaces.ICellArray" href="#fnpcell.interfaces.ICellArray">ICellArray</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.polygon_set"><code class="name flex">
<span>def <span class="ident">polygon_set</span></span>(<span>self, *, layer: <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>, union: bool = True) ‑> <a title="fnpcell.interfaces.IPolygonSet" href="#fnpcell.interfaces.IPolygonSet">IPolygonSet</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.rotated" href="#fnpcell.interfaces.IElement.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.scaled" href="#fnpcell.interfaces.IElement.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.translated" href="#fnpcell.interfaces.IElement.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.v_mirrored" href="#fnpcell.interfaces.IElement.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.with_bands"><code class="name flex">
<span>def <span class="ident">with_bands</span></span>(<span>self: ~_Self, bands: Optional[Iterable[<a title="fnpcell.interfaces.IBand" href="#fnpcell.interfaces.IBand">IBand</a>]]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.with_name"><code class="name flex">
<span>def <span class="ident">with_name</span></span>(<span>self: ~_Self, name: str) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.with_patches"><code class="name flex">
<span>def <span class="ident">with_patches</span></span>(<span>self: ~_Self, content: Iterable[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICellRef.with_ports"><code class="name flex">
<span>def <span class="ident">with_ports</span></span>(<span>self: ~_Self, ports: Sequence[Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>]]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IComposite"><code class="flex name class">
<span>class <span class="ident">IComposite</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of containers.
An IRunnableContainer runs processors to process itself and its content.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IRunnableContainer" href="#fnpcell.interfaces.IRunnableContainer">IRunnableContainer</a></li>
<li>typing.Generic</li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fnpcell.cell.composite._CompositeMixin</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IComposite.content"><code class="name">var <span class="ident">content</span> : Tuple[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IComposite.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.c_mirrored" href="#fnpcell.interfaces.IElement.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self, depth: int = 1) ‑> Tuple[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.h_mirrored" href="#fnpcell.interfaces.IElement.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.rotated" href="#fnpcell.interfaces.IElement.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.scaled" href="#fnpcell.interfaces.IElement.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.translated" href="#fnpcell.interfaces.IElement.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.v_mirrored" href="#fnpcell.interfaces.IElement.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.with_patches"><code class="name flex">
<span>def <span class="ident">with_patches</span></span>(<span>self: ~_Self, content: Iterable[<a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IComposite.with_ports"><code class="name flex">
<span>def <span class="ident">with_ports</span></span>(<span>self, *ports: <a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a>) ‑> <a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICurve"><code class="flex name class">
<span>class <span class="ident">ICurve</span></span>
</code></dt>
<dd>
<div class="desc"><p>IAffineTransformable supports transform, can be scaled, rotated, translated, h_mirrored, v_mirrored, c_mirrored.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.geometry.curve_mixin.CurveMixin" href="geometry/curve_mixin.html#fnpcell.geometry.curve_mixin.CurveMixin">CurveMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurve.transform"><code class="name">var <span class="ident">transform</span> : <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurve.curve_length"><code class="name">var <span class="ident">curve_length</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.curve_points"><code class="name">var <span class="ident">curve_points</span> : Tuple[Tuple[float, float], ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.end_orientations"><code class="name">var <span class="ident">end_orientations</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.end_rays"><code class="name">var <span class="ident">end_rays</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.first_point"><code class="name">var <span class="ident">first_point</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.last_point"><code class="name">var <span class="ident">last_point</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICurve.bundle"><code class="name flex">
<span>def <span class="ident">bundle</span></span>(<span>self, *, size: int, spacing: float, final_spacing: Optional[float] = None, offset: float = 0, final_offset: Optional[float] = None, taper_function: <a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a> = TaperFunctionLinear()) ‑> Tuple[<a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a>, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.c_mirrored" href="#fnpcell.interfaces.IAffineTransformable.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.extended"><code class="name flex">
<span>def <span class="ident">extended</span></span>(<span>self, extension: Tuple[float, float] = (0, 0), end_orientations: Optional[Tuple[float, float]] = None) ‑> <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.h_mirrored" href="#fnpcell.interfaces.IAffineTransformable.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.offsetted"><code class="name flex">
<span>def <span class="ident">offsetted</span></span>(<span>self, offset: float, final_offset: Optional[float] = None, miter_limit: float = inf, taper_function: <a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a> = TaperFunctionLinear()) ‑> <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.rail"><code class="name flex">
<span>def <span class="ident">rail</span></span>(<span>self, width: float, *, offset: float = 0, miter_limit: float = 0.5, final_width: Optional[float] = None, final_offset: Optional[float] = None, taper_function: <a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a> = TaperFunctionLinear()) ‑> Tuple[<a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a>, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.rotated" href="#fnpcell.interfaces.IAffineTransformable.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.sample_at"><code class="name flex">
<span>def <span class="ident">sample_at</span></span>(<span>self, length: float) ‑> <a title="fnpcell.interfaces.SampleInfo" href="#fnpcell.interfaces.SampleInfo">SampleInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>return sample info at length</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.scaled" href="#fnpcell.interfaces.IAffineTransformable.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.split_at"><code class="name flex">
<span>def <span class="ident">split_at</span></span>(<span>self, length: float) ‑> Tuple[<a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a>, <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>return two subcurve at length, if length &lt; 0, abs(length) from end</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.subcurve"><code class="name flex">
<span>def <span class="ident">subcurve</span></span>(<span>self, start: float, end: float) ‑> <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></span>
</code></dt>
<dd>
<div class="desc"><p>return a subcurve between start and end</p>
<p>start: start position in length from start
end: end position in length from start.
If negative, calculate from end</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.to_shape"><code class="name flex">
<span>def <span class="ident">to_shape</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.translated" href="#fnpcell.interfaces.IAffineTransformable.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurve.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.v_mirrored" href="#fnpcell.interfaces.IAffineTransformable.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICurveLike"><code class="flex name class">
<span>class <span class="ident">ICurveLike</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></li>
<li><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></li>
<li><a title="fnpcell.interfaces.IMetalLineLike" href="#fnpcell.interfaces.IMetalLineLike">IMetalLineLike</a></li>
<li><a title="fnpcell.interfaces.IPolyline" href="#fnpcell.interfaces.IPolyline">IPolyline</a></li>
<li><a title="fnpcell.interfaces.IWaveguideLike" href="#fnpcell.interfaces.IWaveguideLike">IWaveguideLike</a></li>
<li><a title="fnpcell.pdk.link_between.flyline.Flyline" href="pdk/link_between/flyline.html#fnpcell.pdk.link_between.flyline.Flyline">Flyline</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurveLike.curve_length"><code class="name">var <span class="ident">curve_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICurvePaint"><code class="flex name class">
<span>class <span class="ident">ICurvePaint</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.curve_paint.CompositeCurvePaint" href="element/curve_paint.html#fnpcell.element.curve_paint.CompositeCurvePaint">CompositeCurvePaint</a></li>
<li><a title="fnpcell.element.curve_paint.ContinuousLayerCurvePaint" href="element/curve_paint.html#fnpcell.element.curve_paint.ContinuousLayerCurvePaint">ContinuousLayerCurvePaint</a></li>
<li><a title="fnpcell.element.curve_paint.PeriodicSamplingCurvePaint" href="element/curve_paint.html#fnpcell.element.curve_paint.PeriodicSamplingCurvePaint">PeriodicSamplingCurvePaint</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.ICurved"><code class="flex name class">
<span>class <span class="ident">ICurved</span></span>
</code></dt>
<dd>
<div class="desc"><p>IAffineTransformable supports transform, can be scaled, rotated, translated, h_mirrored, v_mirrored, c_mirrored.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurvedElement" href="#fnpcell.interfaces.ICurvedElement">ICurvedElement</a></li>
<li><a title="fnpcell.interfaces.IPolyline" href="#fnpcell.interfaces.IPolyline">IPolyline</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurved.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurved.curve"><code class="name">var <span class="ident">curve</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICurved.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.c_mirrored" href="#fnpcell.interfaces.IAffineTransformable.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurved.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.h_mirrored" href="#fnpcell.interfaces.IAffineTransformable.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurved.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.rotated" href="#fnpcell.interfaces.IAffineTransformable.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurved.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.scaled" href="#fnpcell.interfaces.IAffineTransformable.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurved.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.translated" href="#fnpcell.interfaces.IAffineTransformable.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurved.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.v_mirrored" href="#fnpcell.interfaces.IAffineTransformable.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICurvedCellRef"><code class="flex name class">
<span>class <span class="ident">ICurvedCellRef</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fnpcell.cell.cell_ref._ImmutableCurvedCellRef</li>
<li><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></li>
<li><a title="fnpcell.interfaces.IMetalLineLike" href="#fnpcell.interfaces.IMetalLineLike">IMetalLineLike</a></li>
<li><a title="fnpcell.interfaces.IWaveguideLike" href="#fnpcell.interfaces.IWaveguideLike">IWaveguideLike</a></li>
<li><a title="fnpcell.pdk.link_between.flyline.Flyline" href="pdk/link_between/flyline.html#fnpcell.pdk.link_between.flyline.Flyline">Flyline</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurvedCellRef.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICurvedCellRef.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.c_mirrored" href="#fnpcell.interfaces.ICurved.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedCellRef.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.h_mirrored" href="#fnpcell.interfaces.ICurved.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedCellRef.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.rotated" href="#fnpcell.interfaces.ICurved.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedCellRef.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.scaled" href="#fnpcell.interfaces.ICurved.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedCellRef.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.translated" href="#fnpcell.interfaces.ICurved.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedCellRef.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.v_mirrored" href="#fnpcell.interfaces.ICurved.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ICurvedElement"><code class="flex name class">
<span>class <span class="ident">ICurvedElement</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.curve.Curve" href="element/curve.html#fnpcell.element.curve.Curve">Curve</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ICurvedElement.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ICurvedElement.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.c_mirrored" href="#fnpcell.interfaces.ICurved.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedElement.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.h_mirrored" href="#fnpcell.interfaces.ICurved.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedElement.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.rotated" href="#fnpcell.interfaces.ICurved.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedElement.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.scaled" href="#fnpcell.interfaces.ICurved.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedElement.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.translated" href="#fnpcell.interfaces.ICurved.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ICurvedElement.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.v_mirrored" href="#fnpcell.interfaces.ICurved.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IElectronicMaterial"><code class="flex name class">
<span>class <span class="ident">IElectronicMaterial</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IMaterial" href="#fnpcell.interfaces.IMaterial">IMaterial</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IElectronicMaterial.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IElement"><code class="flex name class">
<span>class <span class="ident">IElement</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICellArray" href="#fnpcell.interfaces.ICellArray">ICellArray</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IComposite" href="#fnpcell.interfaces.IComposite">IComposite</a></li>
<li><a title="fnpcell.interfaces.ICurvedElement" href="#fnpcell.interfaces.ICurvedElement">ICurvedElement</a></li>
<li><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IElement.transform"><code class="name">var <span class="ident">transform</span> : <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IElement.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.c_mirrored" href="#fnpcell.interfaces.IAffineTransformable.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IElement.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.h_mirrored" href="#fnpcell.interfaces.IAffineTransformable.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IElement.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.rotated" href="#fnpcell.interfaces.IAffineTransformable.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IElement.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.scaled" href="#fnpcell.interfaces.IAffineTransformable.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IElement.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.translated" href="#fnpcell.interfaces.IAffineTransformable.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IElement.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.v_mirrored" href="#fnpcell.interfaces.IAffineTransformable.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IFont"><code class="flex name class">
<span>class <span class="ident">IFont</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>global unique name for the font, used for <code>hash</code> and <code>eq</code></dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IFont.ascender"><code class="name">var <span class="ident">ascender</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IFont.descender"><code class="name">var <span class="ident">descender</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IFont.glyphs"><code class="name">var <span class="ident">glyphs</span> : Mapping[str, <a title="fnpcell.interfaces.Glyph" href="#fnpcell.interfaces.Glyph">Glyph</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IFont.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IFont.units_per_em"><code class="name">var <span class="ident">units_per_em</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IGroup"><code class="flex name class">
<span>class <span class="ident">IGroup</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of containers.
An IRunnableContainer runs processors to process itself and its content.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IRunnableContainer" href="#fnpcell.interfaces.IRunnableContainer">IRunnableContainer</a></li>
<li>typing.Generic</li>
<li><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></li>
<li><a title="fnpcell.interfaces.ILayered" href="#fnpcell.interfaces.ILayered">ILayered</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.dmtx_code.DataMatrixCode" href="element/dmtx_code.html#fnpcell.element.dmtx_code.DataMatrixCode">DataMatrixCode</a></li>
<li><a title="fnpcell.element.group.Group" href="element/group.html#fnpcell.element.group.Group">Group</a></li>
<li><a title="fnpcell.element.label.Label" href="element/label.html#fnpcell.element.label.Label">Label</a></li>
<li><a title="fnpcell.element.qr_code.QRCode" href="element/qr_code.html#fnpcell.element.qr_code.QRCode">QRCode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IGroup.content"><code class="name">var <span class="ident">content</span> : Tuple[<a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IGroup.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.c_mirrored" href="#fnpcell.interfaces.IPrimitive.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IGroup.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.h_mirrored" href="#fnpcell.interfaces.IPrimitive.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IGroup.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.rotated" href="#fnpcell.interfaces.IPrimitive.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IGroup.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.scaled" href="#fnpcell.interfaces.IPrimitive.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IGroup.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.translated" href="#fnpcell.interfaces.IPrimitive.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IGroup.ungrouped"><code class="name flex">
<span>def <span class="ident">ungrouped</span></span>(<span>self) ‑> Tuple[<a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a>, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>ungrouped self in recursion.</p>
<p>If there's a sub group in the content, the sub group will be ungrouped too.</p>
<p>Return a tuple of IPrimitive.</p></div>
</dd>
<dt id="fnpcell.interfaces.IGroup.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.v_mirrored" href="#fnpcell.interfaces.IPrimitive.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILayer"><code class="flex name class">
<span>class <span class="ident">ILayer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of Layer.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.UnknownLayer" href="#fnpcell.interfaces.UnknownLayer">UnknownLayer</a></li>
<li><a title="fnpcell.pdk.technology.layers.Layer" href="pdk/technology/layers.html#fnpcell.pdk.technology.layers.Layer">Layer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ILayer.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ILayer.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ILayer.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ILayer.process"><code class="name">var <span class="ident">process</span> : <a title="fnpcell.interfaces.IProcess" href="#fnpcell.interfaces.IProcess">IProcess</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ILayer.purpose"><code class="name">var <span class="ident">purpose</span> : <a title="fnpcell.interfaces.IPurpose" href="#fnpcell.interfaces.IPurpose">IPurpose</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ILayer.value"><code class="name">var <span class="ident">value</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILayered"><code class="flex name class">
<span>class <span class="ident">ILayered</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ILayered.layer"><code class="name">var <span class="ident">layer</span> : <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILibrary"><code class="flex name class">
<span>class <span class="ident">ILibrary</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of containers.
An IRunnableContainer runs processors to process itself and its content.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRunnableContainer" href="#fnpcell.interfaces.IRunnableContainer">IRunnableContainer</a></li>
<li>typing.Generic</li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.library.Library" href="cell/library.html#fnpcell.cell.library.Library">Library</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ILibrary.content"><code class="name">var <span class="ident">content</span> : Tuple[<a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILink"><code class="flex name class">
<span>class <span class="ident">ILink</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></li>
<li><a title="fnpcell.pdk.link_smooth.LinkSmooth" href="pdk/link_smooth.html#fnpcell.pdk.link_smooth.LinkSmooth">LinkSmooth</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ILink.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ILink.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.c_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ILink.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.h_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ILink.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.rotated" href="#fnpcell.interfaces.ICurvedCellRef.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ILink.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.scaled" href="#fnpcell.interfaces.ICurvedCellRef.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ILink.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.translated" href="#fnpcell.interfaces.ICurvedCellRef.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ILink.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.v_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILinkBetween"><code class="flex name class">
<span>class <span class="ident">ILinkBetween</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></li>
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IMetalLineBetween" href="#fnpcell.interfaces.IMetalLineBetween">IMetalLineBetween</a></li>
<li><a title="fnpcell.interfaces.IWaveguideBetween" href="#fnpcell.interfaces.IWaveguideBetween">IWaveguideBetween</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ILinkBetween.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ILinkBetween.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code>.<code><a title="fnpcell.interfaces.ILink.c_mirrored" href="#fnpcell.interfaces.ILink.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.ILinkBetween.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code>.<code><a title="fnpcell.interfaces.ILink.h_mirrored" href="#fnpcell.interfaces.ILink.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.ILinkBetween.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code>.<code><a title="fnpcell.interfaces.ILink.rotated" href="#fnpcell.interfaces.ILink.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.ILinkBetween.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code>.<code><a title="fnpcell.interfaces.ILink.scaled" href="#fnpcell.interfaces.ILink.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.ILinkBetween.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code>.<code><a title="fnpcell.interfaces.ILink.translated" href="#fnpcell.interfaces.ILink.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.ILinkBetween.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code>.<code><a title="fnpcell.interfaces.ILink.v_mirrored" href="#fnpcell.interfaces.ILink.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILinkType"><code class="flex name class">
<span>class <span class="ident">ILinkType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IMetalLineType" href="#fnpcell.interfaces.IMetalLineType">IMetalLineType</a></li>
<li><a title="fnpcell.interfaces.IWaveguideType" href="#fnpcell.interfaces.IWaveguideType">IWaveguideType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ILinkType.port_width"><code class="name flex">
<span>def <span class="ident">port_width</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.ILinkingPolicy"><code class="flex name class">
<span>class <span class="ident">ILinkingPolicy</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.auto_link.LinkingPolicy" href="pdk/technology/auto_link.html#fnpcell.pdk.technology.auto_link.LinkingPolicy">LinkingPolicy</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.IMaterial"><code class="flex name class">
<span>class <span class="ident">IMaterial</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IElectronicMaterial" href="#fnpcell.interfaces.IElectronicMaterial">IElectronicMaterial</a></li>
<li><a title="fnpcell.interfaces.IPhotonicMaterial" href="#fnpcell.interfaces.IPhotonicMaterial">IPhotonicMaterial</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IMaterial.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween"><code class="flex name class">
<span>class <span class="ident">IMetalLineBetween</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></li>
<li><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></li>
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.link_between.metal.MetalLineBetween" href="pdk/link_between/metal.html#fnpcell.pdk.link_between.metal.MetalLineBetween">MetalLineBetween</a></li>
<li><a title="fnpcell.pdk.technology.link_between.MetalLineBetween" href="pdk/technology/link_between.html#fnpcell.pdk.technology.link_between.MetalLineBetween">MetalLineBetween</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineBetween.end"><code class="name">var <span class="ident">end</span> : <a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.start"><code class="name">var <span class="ident">start</span> : <a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineBetween.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.c_mirrored" href="#fnpcell.interfaces.ILinkBetween.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.h_mirrored" href="#fnpcell.interfaces.ILinkBetween.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.rotated" href="#fnpcell.interfaces.ILinkBetween.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.scaled" href="#fnpcell.interfaces.ILinkBetween.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.translated" href="#fnpcell.interfaces.ILinkBetween.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.v_mirrored" href="#fnpcell.interfaces.ILinkBetween.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineBetween.with_environment"><code class="name flex">
<span>def <span class="ident">with_environment</span></span>(<span>self: ~_Self, flyline_layer: Optional[<a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>] = None, min_distance: Optional[float] = None, start_distance: Optional[float] = None, end_distance: Optional[float] = None, metal_line_type: Union[None, <a title="fnpcell.interfaces.IMetalLineType" href="#fnpcell.interfaces.IMetalLineType">IMetalLineType</a>, Iterable[Tuple[float, <a title="fnpcell.interfaces.IMetalLineType" href="#fnpcell.interfaces.IMetalLineType">IMetalLineType</a>]]] = None, fitting_function: Optional[Callable[[Tuple[Tuple[float, float], ...]], <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a>]] = None, auto_vias: Optional[<a title="fnpcell.interfaces.IAutoVias" href="#fnpcell.interfaces.IAutoVias">IAutoVias</a>] = None, **kwargs: Any) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IMetalLineLike"><code class="flex name class">
<span>class <span class="ident">IMetalLineLike</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.metal_line.MetalLine" href="cell/metal_line.html#fnpcell.cell.metal_line.MetalLine">MetalLine</a></li>
<li><a title="fnpcell.pdk.link_between.metal.MetalLineBetween" href="pdk/link_between/metal.html#fnpcell.pdk.link_between.metal.MetalLineBetween">MetalLineBetween</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineLike.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineLike.curve_length"><code class="name">var <span class="ident">curve_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineLike.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.c_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineLike.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.h_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineLike.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.rotated" href="#fnpcell.interfaces.ICurvedCellRef.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineLike.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.scaled" href="#fnpcell.interfaces.ICurvedCellRef.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineLike.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.translated" href="#fnpcell.interfaces.ICurvedCellRef.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineLike.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.v_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IMetalLineType"><code class="flex name class">
<span>class <span class="ident">IMetalLineType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILinkType" href="#fnpcell.interfaces.ILinkType">ILinkType</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.metal.MetalLineType" href="pdk/technology/metal.html#fnpcell.pdk.technology.metal.MetalLineType">MetalLineType</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineType.metal_stack"><code class="name">var <span class="ident">metal_stack</span> : <a title="fnpcell.interfaces.IMetalStack" href="#fnpcell.interfaces.IMetalStack">IMetalStack</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IMetalLineType.port_names"><code class="name">var <span class="ident">port_names</span> : Tuple[Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>], Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineType.is_class_isomorphic_to"><code class="name flex">
<span>def <span class="ident">is_class_isomorphic_to</span></span>(<span>other: Type[Any]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalLineType.is_isomorphic_to"><code class="name flex">
<span>def <span class="ident">is_isomorphic_to</span></span>(<span>self, other: <a title="fnpcell.interfaces.IMetalLineType" href="#fnpcell.interfaces.IMetalLineType">IMetalLineType</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IMetalStack"><code class="flex name class">
<span>class <span class="ident">IMetalStack</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.metal_stack.MetalStack" href="pdk/technology/metal_stack.html#fnpcell.pdk.technology.metal_stack.MetalStack">MetalStack</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalStack.connectivity"><code class="name">var <span class="ident">connectivity</span> : Mapping[<a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>, FrozenSet[<a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IMetalStack.layers"><code class="name">var <span class="ident">layers</span> : Tuple[<a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IMetalStack.is_metal"><code class="name flex">
<span>def <span class="ident">is_metal</span></span>(<span>self, layer: <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IOwned"><code class="flex name class">
<span>class <span class="ident">IOwned</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IOwned.owner"><code class="name">var <span class="ident">owner</span> : <a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin"><code class="flex name class">
<span>class <span class="ident">IOwnedPin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class of pin and port.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></li>
<li><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></li>
<li><a title="fnpcell.interfaces.IOwned" href="#fnpcell.interfaces.IOwned">IOwned</a></li>
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.pin.OwnedPin" href="cell/pin.html#fnpcell.cell.pin.OwnedPin">OwnedPin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IOwnedPin.raw"><code class="name">var <span class="ident">raw</span> : <a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IOwnedPin.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></code>.<code><a title="fnpcell.interfaces.IPin.advanced" href="#fnpcell.interfaces.IPin.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.c_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Owner center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.h_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Owner horizontal mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></code>.<code><a title="fnpcell.interfaces.IPin.opposite" href="#fnpcell.interfaces.IPin.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin.repositioned"><code class="name flex">
<span>def <span class="ident">repositioned</span></span>(<span>self, *, at: Union[Tuple[float, float], <a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a>, <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>]) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.repositioned" href="#fnpcell.interfaces.IOwnedTerminal.repositioned">repositioned</a></code>
</p>
<div class="desc inherited"><p>Positioned at new point,Owner will translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, degrees: Optional[float] = None, radians: Optional[float] = None) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.rotated" href="#fnpcell.interfaces.IOwnedTerminal.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Rotated both degrees and radians.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPin.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.v_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Owner vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort"><code class="flex name class">
<span>class <span class="ident">IOwnedPort</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of OwnedPort.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></li>
<li><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></li>
<li><a title="fnpcell.interfaces.IOwned" href="#fnpcell.interfaces.IOwned">IOwned</a></li>
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.port.OwnedPort" href="cell/port.html#fnpcell.cell.port.OwnedPort">OwnedPort</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IOwnedPort.raw"><code class="name">var <span class="ident">raw</span> : <a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IOwnedPort.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></code>.<code><a title="fnpcell.interfaces.IPort.advanced" href="#fnpcell.interfaces.IPort.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.c_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Owner center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.h_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Owner horizontal mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></code>.<code><a title="fnpcell.interfaces.IPort.opposite" href="#fnpcell.interfaces.IPort.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort.repositioned"><code class="name flex">
<span>def <span class="ident">repositioned</span></span>(<span>self, *, at: Union[Tuple[float, float], <a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a>, <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>]) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.repositioned" href="#fnpcell.interfaces.IOwnedTerminal.repositioned">repositioned</a></code>
</p>
<div class="desc inherited"><p>Positioned at new point,Owner will translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, degrees: Optional[float] = None, radians: Optional[float] = None) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.rotated" href="#fnpcell.interfaces.IOwnedTerminal.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Rotated both degrees and radians.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedPort.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code>.<code><a title="fnpcell.interfaces.IOwnedTerminal.v_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Owner vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal"><code class="flex name class">
<span>class <span class="ident">IOwnedTerminal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class of pin and port.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IOwned" href="#fnpcell.interfaces.IOwned">IOwned</a></li>
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IOwnedPin" href="#fnpcell.interfaces.IOwnedPin">IOwnedPin</a></li>
<li><a title="fnpcell.interfaces.IOwnedPort" href="#fnpcell.interfaces.IOwnedPort">IOwnedPort</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IOwnedTerminal.raw"><code class="name">var <span class="ident">raw</span> : <a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IOwnedTerminal.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code>.<code><a title="fnpcell.interfaces.ITerminal.advanced" href="#fnpcell.interfaces.ITerminal.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Owner center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Owner horizontal mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code>.<code><a title="fnpcell.interfaces.ITerminal.opposite" href="#fnpcell.interfaces.ITerminal.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.repositioned"><code class="name flex">
<span>def <span class="ident">repositioned</span></span>(<span>self, *, at: Union[Tuple[float, float], <a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a>, <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>]) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Positioned at new point,Owner will translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, degrees: Optional[float] = None, radians: Optional[float] = None) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rotated both degrees and radians.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Owner vertical mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IOwnedTerminal.with_name"><code class="name flex">
<span>def <span class="ident">with_name</span></span>(<span>self: ~_Self, name: Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPhotonicMaterial"><code class="flex name class">
<span>class <span class="ident">IPhotonicMaterial</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IMaterial" href="#fnpcell.interfaces.IMaterial">IMaterial</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPhotonicMaterial.refractive_index"><code class="name">var <span class="ident">refractive_index</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPin"><code class="flex name class">
<span>class <span class="ident">IPin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class of pin and port.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.pin.OwnedPin" href="cell/pin.html#fnpcell.cell.pin.OwnedPin">OwnedPin</a></li>
<li><a title="fnpcell.cell.pin.Pin" href="cell/pin.html#fnpcell.cell.pin.Pin">Pin</a></li>
<li>fnpcell.cell.pin._PinMixin</li>
<li><a title="fnpcell.interfaces.IOwnedPin" href="#fnpcell.interfaces.IOwnedPin">IOwnedPin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPin.metal_line_type"><code class="name">var <span class="ident">metal_line_type</span> : <a title="fnpcell.interfaces.IMetalLineType" href="#fnpcell.interfaces.IMetalLineType">IMetalLineType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IPin.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code>.<code><a title="fnpcell.interfaces.ITerminal.advanced" href="#fnpcell.interfaces.ITerminal.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IPin.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code>.<code><a title="fnpcell.interfaces.ITerminal.opposite" href="#fnpcell.interfaces.ITerminal.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPolygon"><code class="flex name class">
<span>class <span class="ident">IPolygon</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></li>
<li><a title="fnpcell.interfaces.ILayered" href="#fnpcell.interfaces.ILayered">ILayered</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.polygon.Polygon" href="element/polygon.html#fnpcell.element.polygon.Polygon">Polygon</a></li>
<li><a title="fnpcell.interfaces.IPolyline" href="#fnpcell.interfaces.IPolyline">IPolyline</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPolygon.raw_shape"><code class="name">var <span class="ident">raw_shape</span> : <a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPolygon.polygon_points"><code class="name">var <span class="ident">polygon_points</span> : Tuple[Tuple[float, float], ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolygon.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IPolygon.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.c_mirrored" href="#fnpcell.interfaces.IPrimitive.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygon.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.h_mirrored" href="#fnpcell.interfaces.IPrimitive.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygon.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.rotated" href="#fnpcell.interfaces.IPrimitive.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygon.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.scaled" href="#fnpcell.interfaces.IPrimitive.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygon.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.translated" href="#fnpcell.interfaces.IPrimitive.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygon.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.v_mirrored" href="#fnpcell.interfaces.IPrimitive.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet"><code class="flex name class">
<span>class <span class="ident">IPolygonSet</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></li>
<li><a title="fnpcell.interfaces.ILayered" href="#fnpcell.interfaces.ILayered">ILayered</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.polygon_set.PolygonSet" href="element/polygon_set.html#fnpcell.element.polygon_set.PolygonSet">PolygonSet</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPolygonSet.polygons"><code class="name">var <span class="ident">polygons</span> : Tuple[<a title="fnpcell.interfaces.IPolygon" href="#fnpcell.interfaces.IPolygon">IPolygon</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.region"><code class="name">var <span class="ident">region</span> : <a title="fnpcell.interfaces.IRegion" href="#fnpcell.interfaces.IRegion">IRegion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IPolygonSet.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.c_mirrored" href="#fnpcell.interfaces.IPrimitive.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.h_mirrored" href="#fnpcell.interfaces.IPrimitive.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.inverted"><code class="name flex">
<span>def <span class="ident">inverted</span></span>(<span>self, bounding_shape: <a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a>) ‑> <a title="fnpcell.interfaces.IPolygonSet" href="#fnpcell.interfaces.IPolygonSet">IPolygonSet</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.rotated" href="#fnpcell.interfaces.IPrimitive.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, processor: <a title="fnpcell.interfaces.IProcessor" href="#fnpcell.interfaces.IProcessor">IProcessor</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.scaled" href="#fnpcell.interfaces.IPrimitive.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.translated" href="#fnpcell.interfaces.IPrimitive.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolygonSet.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code>.<code><a title="fnpcell.interfaces.IPrimitive.v_mirrored" href="#fnpcell.interfaces.IPrimitive.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPolyline"><code class="flex name class">
<span>class <span class="ident">IPolyline</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.IPolygon" href="#fnpcell.interfaces.IPolygon">IPolygon</a></li>
<li><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></li>
<li><a title="fnpcell.interfaces.ILayered" href="#fnpcell.interfaces.ILayered">ILayered</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.polyline.Polyline" href="element/polyline.html#fnpcell.element.polyline.Polyline">Polyline</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPolyline.end_hints"><code class="name">var <span class="ident">end_hints</span> : Tuple[Tuple[float, ...], Tuple[float, ...]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.extension"><code class="name">var <span class="ident">extension</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.final_stroke_offset"><code class="name">var <span class="ident">final_stroke_offset</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.final_stroke_width"><code class="name">var <span class="ident">final_stroke_width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.miter_limit"><code class="name">var <span class="ident">miter_limit</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.stroke_offset"><code class="name">var <span class="ident">stroke_offset</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.stroke_width"><code class="name">var <span class="ident">stroke_width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.taper_function"><code class="name">var <span class="ident">taper_function</span> : <a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPolyline.curve_length"><code class="name">var <span class="ident">curve_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.end_rays"><code class="name">var <span class="ident">end_rays</span> : Tuple[<a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>, <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.polyline_points"><code class="name">var <span class="ident">polyline_points</span> : Tuple[Tuple[float, float], ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IPolyline.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.c_mirrored" href="#fnpcell.interfaces.ICurved.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.h_mirrored" href="#fnpcell.interfaces.ICurved.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.rotated" href="#fnpcell.interfaces.ICurved.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.scaled" href="#fnpcell.interfaces.ICurved.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.translated" href="#fnpcell.interfaces.ICurved.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPolyline.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code>.<code><a title="fnpcell.interfaces.ICurved.v_mirrored" href="#fnpcell.interfaces.ICurved.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPort"><code class="flex name class">
<span>class <span class="ident">IPort</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of Port.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.port.Port" href="cell/port.html#fnpcell.cell.port.Port">Port</a></li>
<li>fnpcell.cell.port._PortMixin</li>
<li><a title="fnpcell.interfaces.IOwnedPort" href="#fnpcell.interfaces.IOwnedPort">IOwnedPort</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPort.waveguide_type"><code class="name">var <span class="ident">waveguide_type</span> : <a title="fnpcell.interfaces.IWaveguideType" href="#fnpcell.interfaces.IWaveguideType">IWaveguideType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IPort.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code>.<code><a title="fnpcell.interfaces.ITerminal.advanced" href="#fnpcell.interfaces.ITerminal.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IPort.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code>.<code><a title="fnpcell.interfaces.ITerminal.opposite" href="#fnpcell.interfaces.ITerminal.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPositioned"><code class="flex name class">
<span>class <span class="ident">IPositioned</span></span>
</code></dt>
<dd>
<div class="desc"><p>IPositioned has a position of (x, y)</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.SampleInfo" href="#fnpcell.interfaces.SampleInfo">SampleInfo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPositioned.position"><code class="name">var <span class="ident">position</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPositioned.x"><code class="name">var <span class="ident">x</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPositioned.y"><code class="name">var <span class="ident">y</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPrimitive"><code class="flex name class">
<span>class <span class="ident">IPrimitive</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of element,element is geometry with layer.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILayered" href="#fnpcell.interfaces.ILayered">ILayered</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.element.text.Text" href="element/text.html#fnpcell.element.text.Text">Text</a></li>
<li><a title="fnpcell.interfaces.IGroup" href="#fnpcell.interfaces.IGroup">IGroup</a></li>
<li><a title="fnpcell.interfaces.IPolygon" href="#fnpcell.interfaces.IPolygon">IPolygon</a></li>
<li><a title="fnpcell.interfaces.IPolygonSet" href="#fnpcell.interfaces.IPolygonSet">IPolygonSet</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPrimitive.layer"><code class="name">var <span class="ident">layer</span> : <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IPrimitive.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.c_mirrored" href="#fnpcell.interfaces.IElement.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPrimitive.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.h_mirrored" href="#fnpcell.interfaces.IElement.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IPrimitive.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.rotated" href="#fnpcell.interfaces.IElement.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IPrimitive.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.scaled" href="#fnpcell.interfaces.IElement.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPrimitive.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.translated" href="#fnpcell.interfaces.IElement.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPrimitive.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code>.<code><a title="fnpcell.interfaces.IElement.v_mirrored" href="#fnpcell.interfaces.IElement.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IPrimitive.with_layer"><code class="name flex">
<span>def <span class="ident">with_layer</span></span>(<span>self: ~_Self, layer: <a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IProcess"><code class="flex name class">
<span>class <span class="ident">IProcess</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.UnknownProcess" href="#fnpcell.interfaces.UnknownProcess">UnknownProcess</a></li>
<li><a title="fnpcell.pdk.technology.layers.Process" href="pdk/technology/layers.html#fnpcell.pdk.technology.layers.Process">Process</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IProcess.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IProcess.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IProcess.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IProcess.value"><code class="name">var <span class="ident">value</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IProcessor"><code class="flex name class">
<span>class <span class="ident">IProcessor</span></span>
</code></dt>
<dd>
<div class="desc"><p>An IProcessor processes hierarchical targets in a deep first manner
We use processors to plot, export_gds &hellip;</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fnpcell.gdsii.gds_importer._ReferenceCounter</li>
<li><a title="fnpcell.gdsii.gds_writer.GDSWriter" href="gdsii/gds_writer.html#fnpcell.gdsii.gds_writer.GDSWriter">GDSWriter</a></li>
<li>fnpcell.gdsii.gds_writer._CellCollector</li>
<li><a title="fnpcell.internal.plogic_util.LayoutWriter" href="internal/plogic_util.html#fnpcell.internal.plogic_util.LayoutWriter">LayoutWriter</a></li>
<li><a title="fnpcell.internal.plogic_util.NetlistWriter" href="internal/plogic_util.html#fnpcell.internal.plogic_util.NetlistWriter">NetlistWriter</a></li>
<li>fnpcell.internal.plogic_util._LayoutCellCollector</li>
<li>fnpcell.internal.plogic_util._NetlistCellCollector</li>
<li>fnpcell.internal.util.layout_util._BBox</li>
<li><a title="fnpcell.internal.util.statistics.Statistics" href="internal/util/statistics.html#fnpcell.internal.util.statistics.Statistics">Statistics</a></li>
<li><a title="fnpcell.netlist.spc_writer.SPCWriter" href="netlist/spc_writer.html#fnpcell.netlist.spc_writer.SPCWriter">SPCWriter</a></li>
<li>fnpcell.netlist.spc_writer._CellCollector</li>
<li><a title="fnpcell.processors.matplotlib_shower.MatplotlibShower" href="processors/matplotlib_shower.html#fnpcell.processors.matplotlib_shower.MatplotlibShower">MatplotlibShower</a></li>
<li><a title="fnpcell.processors.port_owner_checker.PortOwnerChecker" href="processors/port_owner_checker.html#fnpcell.processors.port_owner_checker.PortOwnerChecker">PortOwnerChecker</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IProcessor.enter"><code class="name flex">
<span>def <span class="ident">enter</span></span>(<span>self, target: Any) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Called before processing a target.
Return
True to continue processing child content.
False to stop here and run exit for the target</p></div>
</dd>
<dt id="fnpcell.interfaces.IProcessor.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self, target: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Called after processing a target.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IPurpose"><code class="flex name class">
<span>class <span class="ident">IPurpose</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.UnknownPurpose" href="#fnpcell.interfaces.UnknownPurpose">UnknownPurpose</a></li>
<li><a title="fnpcell.pdk.technology.layers.Purpose" href="pdk/technology/layers.html#fnpcell.pdk.technology.layers.Purpose">Purpose</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IPurpose.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPurpose.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPurpose.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IPurpose.value"><code class="name">var <span class="ident">value</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IRay"><code class="flex name class">
<span>class <span class="ident">IRay</span></span>
</code></dt>
<dd>
<div class="desc"><p>IRay has a position and an orientation</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.interfaces.Ray" href="#fnpcell.interfaces.Ray">Ray</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IRay.orientation"><code class="name">var <span class="ident">orientation</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IRay.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.IRay.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IRegion"><code class="flex name class">
<span>class <span class="ident">IRegion</span></span>
</code></dt>
<dd>
<div class="desc"><p>IAffineTransformable supports transform, can be scaled, rotated, translated, h_mirrored, v_mirrored, c_mirrored.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.geometry.region.Region" href="geometry/region.html#fnpcell.geometry.region.Region">Region</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IRegion.shapes"><code class="name">var <span class="ident">shapes</span> : Tuple[<a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IRegion.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.c_mirrored" href="#fnpcell.interfaces.IAffineTransformable.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IRegion.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.h_mirrored" href="#fnpcell.interfaces.IAffineTransformable.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IRegion.merged"><code class="name flex">
<span>def <span class="ident">merged</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IRegion" href="#fnpcell.interfaces.IRegion">IRegion</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IRegion.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.rotated" href="#fnpcell.interfaces.IAffineTransformable.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IRegion.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.scaled" href="#fnpcell.interfaces.IAffineTransformable.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IRegion.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.translated" href="#fnpcell.interfaces.IAffineTransformable.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IRegion.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.v_mirrored" href="#fnpcell.interfaces.IAffineTransformable.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IRunnable"><code class="flex name class">
<span>class <span class="ident">IRunnable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Super class of all element.
An IRunnable runs processors to process itself.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnableContainer" href="#fnpcell.interfaces.IRunnableContainer">IRunnableContainer</a></li>
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IRunnable.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self: ~_Self, processor: <a title="fnpcell.interfaces.IProcessor" href="#fnpcell.interfaces.IProcessor">IProcessor</a>) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IRunnableContainer"><code class="flex name class">
<span>class <span class="ident">IRunnableContainer</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of containers.
An IRunnableContainer runs processors to process itself and its content.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></li>
<li><a title="fnpcell.interfaces.IComposite" href="#fnpcell.interfaces.IComposite">IComposite</a></li>
<li><a title="fnpcell.interfaces.IGroup" href="#fnpcell.interfaces.IGroup">IGroup</a></li>
<li><a title="fnpcell.interfaces.ILibrary" href="#fnpcell.interfaces.ILibrary">ILibrary</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IRunnableContainer.content"><code class="name">var <span class="ident">content</span> : Iterable[~_Ru]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IRunnableContainer.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self: ~_Self, processor: <a title="fnpcell.interfaces.IProcessor" href="#fnpcell.interfaces.IProcessor">IProcessor</a>) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IShape"><code class="flex name class">
<span>class <span class="ident">IShape</span></span>
</code></dt>
<dd>
<div class="desc"><p>IAffineTransformable supports transform, can be scaled, rotated, translated, h_mirrored, v_mirrored, c_mirrored.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.geometry.shape.Shape" href="geometry/shape.html#fnpcell.geometry.shape.Shape">Shape</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IShape.transform"><code class="name">var <span class="ident">transform</span> : <a title="fnpcell.transform.Affine2D" href="transform.html#fnpcell.transform.Affine2D">Affine2D</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IShape.shape_points"><code class="name">var <span class="ident">shape_points</span> : Tuple[Tuple[float, float], ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IShape.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.c_mirrored" href="#fnpcell.interfaces.IAffineTransformable.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IShape.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.h_mirrored" href="#fnpcell.interfaces.IAffineTransformable.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IShape.offsetted"><code class="name flex">
<span>def <span class="ident">offsetted</span></span>(<span>self, offset: float) ‑> <a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IShape.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.rotated" href="#fnpcell.interfaces.IAffineTransformable.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IShape.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.scaled" href="#fnpcell.interfaces.IAffineTransformable.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IShape.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.translated" href="#fnpcell.interfaces.IAffineTransformable.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IShape.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code>.<code><a title="fnpcell.interfaces.IAffineTransformable.v_mirrored" href="#fnpcell.interfaces.IAffineTransformable.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IStraightWaveguideFactory"><code class="flex name class">
<span>class <span class="ident">IStraightWaveguideFactory</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="fnpcell.interfaces.ITaperCallable"><code class="flex name class">
<span>class <span class="ident">ITaperCallable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.TaperFunctionLinear" href="#fnpcell.interfaces.TaperFunctionLinear">TaperFunctionLinear</a></li>
<li><a title="fnpcell.interfaces.TaperFunctionParabolic" href="#fnpcell.interfaces.TaperFunctionParabolic">TaperFunctionParabolic</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.ITerminal"><code class="flex name class">
<span>class <span class="ident">ITerminal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class of pin and port.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></li>
<li><a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></li>
<li><a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.ITerminal.hidden"><code class="name">var <span class="ident">hidden</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.name"><code class="name">var <span class="ident">name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.orientation"><code class="name">var <span class="ident">orientation</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.shape"><code class="name">var <span class="ident">shape</span> : <a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.ITerminal.annotation"><code class="name">var <span class="ident">annotation</span> : <a title="fnpcell.interfaces.IComposite" href="#fnpcell.interfaces.IComposite">IComposite</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.disabled"><code class="name">var <span class="ident">disabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.ITerminal.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self: ~_Self, distance: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></code>.<code><a title="fnpcell.interfaces.IRay.advanced" href="#fnpcell.interfaces.IRay.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self, other: <a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self: ~_Self) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></code>.<code><a title="fnpcell.interfaces.IRay.opposite" href="#fnpcell.interfaces.IRay.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, processor: <a title="fnpcell.interfaces.IProcessor" href="#fnpcell.interfaces.IProcessor">IProcessor</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.with_name"><code class="name flex">
<span>def <span class="ident">with_name</span></span>(<span>self: ~_Self, name: Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>]) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.ITerminal.with_orientation"><code class="name flex">
<span>def <span class="ident">with_orientation</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IUpdatable"><code class="flex name class">
<span>class <span class="ident">IUpdatable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.ILibrary" href="#fnpcell.interfaces.ILibrary">ILibrary</a></li>
<li><a title="fnpcell.interfaces.ILinkType" href="#fnpcell.interfaces.ILinkType">ILinkType</a></li>
<li><a title="fnpcell.interfaces.IMetalStack" href="#fnpcell.interfaces.IMetalStack">IMetalStack</a></li>
<li><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></li>
<li><a title="fnpcell.mixin.transform_mixin.TransformMixin" href="mixin/transform_mixin.html#fnpcell.mixin.transform_mixin.TransformMixin">TransformMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IUpdatable.updated"><code class="name flex">
<span>def <span class="ident">updated</span></span>(<span>self: ~_Self, **kwargs: Any) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IViasFactory"><code class="flex name class">
<span>class <span class="ident">IViasFactory</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween"><code class="flex name class">
<span>class <span class="ident">IWaveguideBetween</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></li>
<li><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></li>
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.link_between.wg.WaveguideBetween" href="pdk/link_between/wg.html#fnpcell.pdk.link_between.wg.WaveguideBetween">WaveguideBetween</a></li>
<li><a title="fnpcell.pdk.technology.link_between.WaveguideBetween" href="pdk/technology/link_between.html#fnpcell.pdk.technology.link_between.WaveguideBetween">WaveguideBetween</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideBetween.end"><code class="name">var <span class="ident">end</span> : <a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.start"><code class="name">var <span class="ident">start</span> : <a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideBetween.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.c_mirrored" href="#fnpcell.interfaces.ILinkBetween.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.h_mirrored" href="#fnpcell.interfaces.ILinkBetween.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.rotated" href="#fnpcell.interfaces.ILinkBetween.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.scaled" href="#fnpcell.interfaces.ILinkBetween.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.translated" href="#fnpcell.interfaces.ILinkBetween.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code>.<code><a title="fnpcell.interfaces.ILinkBetween.v_mirrored" href="#fnpcell.interfaces.ILinkBetween.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideBetween.with_environment"><code class="name flex">
<span>def <span class="ident">with_environment</span></span>(<span>self: ~_Self, flyline_layer: Optional[<a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a>] = None, linking_policy: Optional[<a title="fnpcell.interfaces.ILinkingPolicy" href="#fnpcell.interfaces.ILinkingPolicy">ILinkingPolicy</a>] = None, link_type: Optional[<a title="fnpcell.interfaces.IWaveguideType" href="#fnpcell.interfaces.IWaveguideType">IWaveguideType</a>] = None, straight_factory: Optional[<a title="fnpcell.interfaces.IStraightWaveguideFactory" href="#fnpcell.interfaces.IStraightWaveguideFactory">IStraightWaveguideFactory</a>] = None, bend_factory: Optional[<a title="fnpcell.interfaces.IBendWaveguideFactory" href="#fnpcell.interfaces.IBendWaveguideFactory">IBendWaveguideFactory</a>] = None, **kwargs: Any) ‑> ~_Self</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IWaveguideLike"><code class="flex name class">
<span>class <span class="ident">IWaveguideLike</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface of CellRef</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></li>
<li><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></li>
<li><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></li>
<li><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
<li><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></li>
<li><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></li>
<li><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.cell.waveguide.Waveguide" href="cell/waveguide.html#fnpcell.cell.waveguide.Waveguide">Waveguide</a></li>
<li><a title="fnpcell.pdk.link_between.wg.WaveguideBetween" href="pdk/link_between/wg.html#fnpcell.pdk.link_between.wg.WaveguideBetween">WaveguideBetween</a></li>
<li><a title="fnpcell.pdk.link_smooth.LinkSmooth" href="pdk/link_smooth.html#fnpcell.pdk.link_smooth.LinkSmooth">LinkSmooth</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideLike.raw_curve"><code class="name">var <span class="ident">raw_curve</span> : <a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideLike.curve_length"><code class="name">var <span class="ident">curve_length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideLike.c_mirrored"><code class="name flex">
<span>def <span class="ident">c_mirrored</span></span>(<span>self: ~_Self, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.c_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.c_mirrored">c_mirrored</a></code>
</p>
<div class="desc inherited"><p>Center mirrored.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideLike.h_mirrored"><code class="name flex">
<span>def <span class="ident">h_mirrored</span></span>(<span>self: ~_Self, *, x: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.h_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.h_mirrored">h_mirrored</a></code>
</p>
<div class="desc inherited"><p>Horizontal mirrored</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideLike.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self: ~_Self, *, degrees: Optional[float] = None, radians: Optional[float] = None, origin: Optional[Tuple[float, float]] = None, inplace: Optional[bool] = None) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.rotated" href="#fnpcell.interfaces.ICurvedCellRef.rotated">rotated</a></code>
</p>
<div class="desc inherited"><p>Return a new cell reference rotated, either degrees or radians must be provided.
If both provided, radians is used …</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideLike.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self: ~_Self, sx: float, sy: Optional[float] = None, *, center: Tuple[float, float] = (0, 0)) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.scaled" href="#fnpcell.interfaces.ICurvedCellRef.scaled">scaled</a></code>
</p>
<div class="desc inherited"><p>scaled at center.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideLike.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self: ~_Self, tx: float, ty: float) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.translated" href="#fnpcell.interfaces.ICurvedCellRef.translated">translated</a></code>
</p>
<div class="desc inherited"><p>Translated.</p></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideLike.v_mirrored"><code class="name flex">
<span>def <span class="ident">v_mirrored</span></span>(<span>self: ~_Self, *, y: float = 0) ‑> ~_Self</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code>.<code><a title="fnpcell.interfaces.ICurvedCellRef.v_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.v_mirrored">v_mirrored</a></code>
</p>
<div class="desc inherited"><p>Vertical mirrored.</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.IWaveguideType"><code class="flex name class">
<span>class <span class="ident">IWaveguideType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILinkType" href="#fnpcell.interfaces.ILinkType">ILinkType</a></li>
<li><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.wg.WaveguideType" href="pdk/technology/wg.html#fnpcell.pdk.technology.wg.WaveguideType">WaveguideType</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideType.bend_factory"><code class="name">var <span class="ident">bend_factory</span> : <a title="fnpcell.interfaces.IBendWaveguideFactory" href="#fnpcell.interfaces.IBendWaveguideFactory">IBendWaveguideFactory</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideType.port_names"><code class="name">var <span class="ident">port_names</span> : Tuple[Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>], Union[None, str, <a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.IWaveguideType.straight_factory"><code class="name">var <span class="ident">straight_factory</span> : <a title="fnpcell.interfaces.IStraightWaveguideFactory" href="#fnpcell.interfaces.IStraightWaveguideFactory">IStraightWaveguideFactory</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideType.is_class_isomorphic_to"><code class="name flex">
<span>def <span class="ident">is_class_isomorphic_to</span></span>(<span>other: Type[Any]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideType.band"><code class="name">var <span class="ident">band</span> : <a title="fnpcell.interfaces.IBand" href="#fnpcell.interfaces.IBand">IBand</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.IWaveguideType.is_isomorphic_to"><code class="name flex">
<span>def <span class="ident">is_isomorphic_to</span></span>(<span>self, other: <a title="fnpcell.interfaces.IWaveguideType" href="#fnpcell.interfaces.IWaveguideType">IWaveguideType</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Offset"><code class="flex name class">
<span>class <span class="ident">Offset</span></span>
<span>(</span><span>x: Union[None, float, <a title="fnpcell.interfaces.Absolute" href="#fnpcell.interfaces.Absolute">Absolute</a>] = None, y: Union[None, float, <a title="fnpcell.interfaces.Absolute" href="#fnpcell.interfaces.Absolute">Absolute</a>] = None, relative_to: <a title="fnpcell.interfaces.RelativeTo" href="#fnpcell.interfaces.RelativeTo">RelativeTo</a> = RelativeTo.PREV)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset(x: Union[NoneType, float, fnpcell.interfaces.Absolute] = None, y: Union[NoneType, float, fnpcell.interfaces.Absolute] = None, relative_to: fnpcell.interfaces.RelativeTo = fnpcell.interfaces.RelativeTo.PREV)</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Offset.relative_to"><code class="name">var <span class="ident">relative_to</span> : <a title="fnpcell.interfaces.RelativeTo" href="#fnpcell.interfaces.RelativeTo">RelativeTo</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Offset.x"><code class="name">var <span class="ident">x</span> : Union[None, float, <a title="fnpcell.interfaces.Absolute" href="#fnpcell.interfaces.Absolute">Absolute</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Offset.y"><code class="name">var <span class="ident">y</span> : Union[None, float, <a title="fnpcell.interfaces.Absolute" href="#fnpcell.interfaces.Absolute">Absolute</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fnpcell.interfaces.Offset.from_end"><code class="name flex">
<span>def <span class="ident">from_end</span></span>(<span>x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Offset.from_start"><code class="name flex">
<span>def <span class="ident">from_start</span></span>(<span>x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Offset.until_x"><code class="name flex">
<span>def <span class="ident">until_x</span></span>(<span>x: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Offset.until_y"><code class="name flex">
<span>def <span class="ident">until_y</span></span>(<span>y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Ray"><code class="flex name class">
<span>class <span class="ident">Ray</span></span>
<span>(</span><span>position: Tuple[float, float], orientation: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Ray(position: Tuple[float, float], orientation: float)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></li>
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Ray.orientation"><code class="name">var <span class="ident">orientation</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Ray.position"><code class="name">var <span class="ident">position</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fnpcell.interfaces.Ray.advanced"><code class="name flex">
<span>def <span class="ident">advanced</span></span>(<span>self, distance: float) ‑> <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></code>.<code><a title="fnpcell.interfaces.IRay.advanced" href="#fnpcell.interfaces.IRay.advanced">advanced</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with advanced position through orientation</p></div>
</dd>
<dt id="fnpcell.interfaces.Ray.opposite"><code class="name flex">
<span>def <span class="ident">opposite</span></span>(<span>self) ‑> <a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></code>.<code><a title="fnpcell.interfaces.IRay.opposite" href="#fnpcell.interfaces.IRay.opposite">opposite</a></code>
</p>
<div class="desc inherited"><p>Return an IRay with same position but opposite orientation</p></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.RelativeTo"><code class="flex name class">
<span>class <span class="ident">RelativeTo</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.RelativeTo.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.RelativeTo.PREV"><code class="name">var <span class="ident">PREV</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.RelativeTo.START"><code class="name">var <span class="ident">START</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.SampleInfo"><code class="flex name class">
<span>class <span class="ident">SampleInfo</span></span>
<span>(</span><span>position: Tuple[float, float], orientation: float, length: float)</span>
</code></dt>
<dd>
<div class="desc"><p>SampleInfo(position: Tuple[float, float], orientation: float, length: float)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.SampleInfo.length"><code class="name">var <span class="ident">length</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.SampleInfo.orientation"><code class="name">var <span class="ident">orientation</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.SampleInfo.position"><code class="name">var <span class="ident">position</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.TaperFunction"><code class="flex name class">
<span>class <span class="ident">TaperFunction</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.TaperFunction.LINEAR"><code class="name">var <span class="ident">LINEAR</span> : <a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.TaperFunction.PARABOLIC"><code class="name">var <span class="ident">PARABOLIC</span> : <a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.TaperFunctionLinear"><code class="flex name class">
<span>class <span class="ident">TaperFunctionLinear</span></span>
</code></dt>
<dd>
<div class="desc"><p>TaperFunctionLinear()</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.TaperFunctionParabolic"><code class="flex name class">
<span>class <span class="ident">TaperFunctionParabolic</span></span>
</code></dt>
<dd>
<div class="desc"><p>TaperFunctionParabolic()</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.TextBaseline"><code class="flex name class">
<span>class <span class="ident">TextBaseline</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.TextBaseline.ALPHABETIC"><code class="name">var <span class="ident">ALPHABETIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.TextBaseline.BOTTOM"><code class="name">var <span class="ident">BOTTOM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.TextBaseline.TOP"><code class="name">var <span class="ident">TOP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Type2TypeMeta"><code class="flex name class">
<span>class <span class="ident">Type2TypeMeta</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Metaclass for defining Abstract Base Classes (ABCs).</p>
<p>Use this metaclass to create an ABC.
An ABC can be subclassed
directly, and then acts as a mix-in class.
You can also register
unrelated concrete classes (even built-in classes) and unrelated
ABCs as 'virtual subclasses' &ndash; these and their descendants will
be considered subclasses of the registering ABC by the built-in
issubclass() function, but the registering ABC won't show up in
their MRO (Method Resolution Order) nor will method
implementations defined by the registering ABC be callable (not
even via super()).</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABCMeta</li>
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fnpcell.pdk.technology.metal.MetalLineTypeMeta" href="pdk/technology/metal.html#fnpcell.pdk.technology.metal.MetalLineTypeMeta">MetalLineTypeMeta</a></li>
<li><a title="fnpcell.pdk.technology.wg.WaveguideTypeMeta" href="pdk/technology/wg.html#fnpcell.pdk.technology.wg.WaveguideTypeMeta">WaveguideTypeMeta</a></li>
</ul>
</dd>
<dt id="fnpcell.interfaces.Unimplemented"><code class="flex name class">
<span>class <span class="ident">Unimplemented</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unimplemented(message: str)</p></div>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Unimplemented.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.UnknownLayer"><code class="flex name class">
<span>class <span class="ident">UnknownLayer</span></span>
<span>(</span><span>value: Tuple[int, int], description: str = '', order: int = -1, name_template: str = 'Layer({value[0]}/{value[1]})')</span>
</code></dt>
<dd>
<div class="desc"><p>UnknownLayer(value: Tuple[int, int], description: str = '', order: int = -1, name_template: str = 'Layer({value[0]}/{value[1]})')</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.UnknownLayer.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownLayer.name_template"><code class="name">var <span class="ident">name_template</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownLayer.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownLayer.value"><code class="name">var <span class="ident">value</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.UnknownLayer.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownLayer.process"><code class="name">var <span class="ident">process</span> : <a title="fnpcell.interfaces.IProcess" href="#fnpcell.interfaces.IProcess">IProcess</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownLayer.purpose"><code class="name">var <span class="ident">purpose</span> : <a title="fnpcell.interfaces.IPurpose" href="#fnpcell.interfaces.IPurpose">IPurpose</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.UnknownProcess"><code class="flex name class">
<span>class <span class="ident">UnknownProcess</span></span>
<span>(</span><span>value: int, description: str = '', order: int = -1, name_template: str = 'Process(value)')</span>
</code></dt>
<dd>
<div class="desc"><p>UnknownProcess(value: int, description: str = '', order: int = -1, name_template: str = 'Process(value)')</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IProcess" href="#fnpcell.interfaces.IProcess">IProcess</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.UnknownProcess.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownProcess.name_template"><code class="name">var <span class="ident">name_template</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownProcess.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownProcess.value"><code class="name">var <span class="ident">value</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.UnknownProcess.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.UnknownPurpose"><code class="flex name class">
<span>class <span class="ident">UnknownPurpose</span></span>
<span>(</span><span>value: int, description: str = '', order: int = -1, name_template: str = 'Purpose(value)')</span>
</code></dt>
<dd>
<div class="desc"><p>UnknownPurpose(value: int, description: str = '', order: int = -1, name_template: str = 'Purpose(value)')</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fnpcell.interfaces.IPurpose" href="#fnpcell.interfaces.IPurpose">IPurpose</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.UnknownPurpose.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownPurpose.name_template"><code class="name">var <span class="ident">name_template</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownPurpose.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.UnknownPurpose.value"><code class="name">var <span class="ident">value</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fnpcell.interfaces.UnknownPurpose.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.VertialAlign"><code class="flex name class">
<span>class <span class="ident">VertialAlign</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.VertialAlign.BOTTOM"><code class="name">var <span class="ident">BOTTOM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.VertialAlign.MIDDLE"><code class="name">var <span class="ident">MIDDLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.VertialAlign.TOP"><code class="name">var <span class="ident">TOP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fnpcell.interfaces.Waypoints"><code class="flex name class">
<span>class <span class="ident">Waypoints</span></span>
<span>(</span><span>start: +_L, middle: Tuple[<a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>, ...], end: +_R)</span>
</code></dt>
<dd>
<div class="desc"><p>Waypoints(<em>args, </em>*kwds)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fnpcell.interfaces.Waypoints.end"><code class="name">var <span class="ident">end</span> : +_R</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Waypoints.middle"><code class="name">var <span class="ident">middle</span> : Tuple[<a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a>, ...]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fnpcell.interfaces.Waypoints.start"><code class="name">var <span class="ident">start</span> : +_L</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="assets/tingle/0.15.3/tingle.min.css">
<script src="assets/tingle/0.15.3/tingle.min.js"></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fnpcell" href="index.html">fnpcell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.Waypoint" href="#fnpcell.interfaces.Waypoint">Waypoint</a></code></li>
<li><code><a title="fnpcell.interfaces.angle_between" href="#fnpcell.interfaces.angle_between">angle_between</a></code></li>
<li><code><a title="fnpcell.interfaces.cache" href="#fnpcell.interfaces.cache">cache</a></code></li>
<li><code><a title="fnpcell.interfaces.clamp" href="#fnpcell.interfaces.clamp">clamp</a></code></li>
<li><code><a title="fnpcell.interfaces.distance_between" href="#fnpcell.interfaces.distance_between">distance_between</a></code></li>
<li><code><a title="fnpcell.interfaces.is_abstract" href="#fnpcell.interfaces.is_abstract">is_abstract</a></code></li>
<li><code><a title="fnpcell.interfaces.is_dataclass" href="#fnpcell.interfaces.is_dataclass">is_dataclass</a></code></li>
<li><code><a title="fnpcell.interfaces.midpoint_of" href="#fnpcell.interfaces.midpoint_of">midpoint_of</a></code></li>
<li><code><a title="fnpcell.interfaces.normalize_angle" href="#fnpcell.interfaces.normalize_angle">normalize_angle</a></code></li>
<li><code><a title="fnpcell.interfaces.transform_between" href="#fnpcell.interfaces.transform_between">transform_between</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fnpcell.interfaces.Absolute" href="#fnpcell.interfaces.Absolute">Absolute</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.Absolute.value" href="#fnpcell.interfaces.Absolute.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Anchor" href="#fnpcell.interfaces.Anchor">Anchor</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.Anchor.CENTER" href="#fnpcell.interfaces.Anchor.CENTER">CENTER</a></code></li>
<li><code><a title="fnpcell.interfaces.Anchor.END" href="#fnpcell.interfaces.Anchor.END">END</a></code></li>
<li><code><a title="fnpcell.interfaces.Anchor.START" href="#fnpcell.interfaces.Anchor.START">START</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.FrozenDict" href="#fnpcell.interfaces.FrozenDict">FrozenDict</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.FrozenDict.freeze" href="#fnpcell.interfaces.FrozenDict.freeze">freeze</a></code></li>
<li><code><a title="fnpcell.interfaces.FrozenDict.get" href="#fnpcell.interfaces.FrozenDict.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Glyph" href="#fnpcell.interfaces.Glyph">Glyph</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.Glyph.advance_width" href="#fnpcell.interfaces.Glyph.advance_width">advance_width</a></code></li>
<li><code><a title="fnpcell.interfaces.Glyph.bounding_box" href="#fnpcell.interfaces.Glyph.bounding_box">bounding_box</a></code></li>
<li><code><a title="fnpcell.interfaces.Glyph.highlight_box" href="#fnpcell.interfaces.Glyph.highlight_box">highlight_box</a></code></li>
<li><code><a title="fnpcell.interfaces.Glyph.left_side_bearing" href="#fnpcell.interfaces.Glyph.left_side_bearing">left_side_bearing</a></code></li>
<li><code><a title="fnpcell.interfaces.Glyph.paths" href="#fnpcell.interfaces.Glyph.paths">paths</a></code></li>
<li><code><a title="fnpcell.interfaces.Glyph.right_side_bearing" href="#fnpcell.interfaces.Glyph.right_side_bearing">right_side_bearing</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Hidden" href="#fnpcell.interfaces.Hidden">Hidden</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.Hidden.name" href="#fnpcell.interfaces.Hidden.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IAffineTransformable" href="#fnpcell.interfaces.IAffineTransformable">IAffineTransformable</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IAffineTransformable.c_mirrored" href="#fnpcell.interfaces.IAffineTransformable.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.h_mirrored" href="#fnpcell.interfaces.IAffineTransformable.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.rotated" href="#fnpcell.interfaces.IAffineTransformable.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.scaled" href="#fnpcell.interfaces.IAffineTransformable.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.transform" href="#fnpcell.interfaces.IAffineTransformable.transform">transform</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.transform_combined" href="#fnpcell.interfaces.IAffineTransformable.transform_combined">transform_combined</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.translated" href="#fnpcell.interfaces.IAffineTransformable.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IAffineTransformable.v_mirrored" href="#fnpcell.interfaces.IAffineTransformable.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IAutoVias" href="#fnpcell.interfaces.IAutoVias">IAutoVias</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IBand" href="#fnpcell.interfaces.IBand">IBand</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IBand.name" href="#fnpcell.interfaces.IBand.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IBendCurveFactory" href="#fnpcell.interfaces.IBendCurveFactory">IBendCurveFactory</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IBendWaveguideFactory" href="#fnpcell.interfaces.IBendWaveguideFactory">IBendWaveguideFactory</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICell" href="#fnpcell.interfaces.ICell">ICell</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICell.bands" href="#fnpcell.interfaces.ICell.bands">bands</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.content" href="#fnpcell.interfaces.ICell.content">content</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.name" href="#fnpcell.interfaces.ICell.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.new_array" href="#fnpcell.interfaces.ICell.new_array">new_array</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.new_ref" href="#fnpcell.interfaces.ICell.new_ref">new_ref</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.polygon_set" href="#fnpcell.interfaces.ICell.polygon_set">polygon_set</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.ports" href="#fnpcell.interfaces.ICell.ports">ports</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.with_bands" href="#fnpcell.interfaces.ICell.with_bands">with_bands</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.with_content" href="#fnpcell.interfaces.ICell.with_content">with_content</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.with_name" href="#fnpcell.interfaces.ICell.with_name">with_name</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.with_patches" href="#fnpcell.interfaces.ICell.with_patches">with_patches</a></code></li>
<li><code><a title="fnpcell.interfaces.ICell.with_ports" href="#fnpcell.interfaces.ICell.with_ports">with_ports</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICellArray" href="#fnpcell.interfaces.ICellArray">ICellArray</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICellArray.c_mirrored" href="#fnpcell.interfaces.ICellArray.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.cell" href="#fnpcell.interfaces.ICellArray.cell">cell</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.col_end" href="#fnpcell.interfaces.ICellArray.col_end">col_end</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.cols" href="#fnpcell.interfaces.ICellArray.cols">cols</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.decompose" href="#fnpcell.interfaces.ICellArray.decompose">decompose</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.h_mirrored" href="#fnpcell.interfaces.ICellArray.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.polygon_set" href="#fnpcell.interfaces.ICellArray.polygon_set">polygon_set</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.rotated" href="#fnpcell.interfaces.ICellArray.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.row_end" href="#fnpcell.interfaces.ICellArray.row_end">row_end</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.rows" href="#fnpcell.interfaces.ICellArray.rows">rows</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.scaled" href="#fnpcell.interfaces.ICellArray.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.transform" href="#fnpcell.interfaces.ICellArray.transform">transform</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.translated" href="#fnpcell.interfaces.ICellArray.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellArray.v_mirrored" href="#fnpcell.interfaces.ICellArray.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICellRef" href="#fnpcell.interfaces.ICellRef">ICellRef</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICellRef.c_mirrored" href="#fnpcell.interfaces.ICellRef.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.cell" href="#fnpcell.interfaces.ICellRef.cell">cell</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.content_merged" href="#fnpcell.interfaces.ICellRef.content_merged">content_merged</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.flatten" href="#fnpcell.interfaces.ICellRef.flatten">flatten</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.frozen" href="#fnpcell.interfaces.ICellRef.frozen">frozen</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.h_mirrored" href="#fnpcell.interfaces.ICellRef.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.new_array" href="#fnpcell.interfaces.ICellRef.new_array">new_array</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.polygon_set" href="#fnpcell.interfaces.ICellRef.polygon_set">polygon_set</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.ports" href="#fnpcell.interfaces.ICellRef.ports">ports</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.rotated" href="#fnpcell.interfaces.ICellRef.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.scaled" href="#fnpcell.interfaces.ICellRef.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.transform" href="#fnpcell.interfaces.ICellRef.transform">transform</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.translated" href="#fnpcell.interfaces.ICellRef.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.v_mirrored" href="#fnpcell.interfaces.ICellRef.v_mirrored">v_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.with_bands" href="#fnpcell.interfaces.ICellRef.with_bands">with_bands</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.with_name" href="#fnpcell.interfaces.ICellRef.with_name">with_name</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.with_patches" href="#fnpcell.interfaces.ICellRef.with_patches">with_patches</a></code></li>
<li><code><a title="fnpcell.interfaces.ICellRef.with_ports" href="#fnpcell.interfaces.ICellRef.with_ports">with_ports</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IComposite" href="#fnpcell.interfaces.IComposite">IComposite</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IComposite.c_mirrored" href="#fnpcell.interfaces.IComposite.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.content" href="#fnpcell.interfaces.IComposite.content">content</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.flatten" href="#fnpcell.interfaces.IComposite.flatten">flatten</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.h_mirrored" href="#fnpcell.interfaces.IComposite.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.rotated" href="#fnpcell.interfaces.IComposite.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.scaled" href="#fnpcell.interfaces.IComposite.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.translated" href="#fnpcell.interfaces.IComposite.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.v_mirrored" href="#fnpcell.interfaces.IComposite.v_mirrored">v_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.with_patches" href="#fnpcell.interfaces.IComposite.with_patches">with_patches</a></code></li>
<li><code><a title="fnpcell.interfaces.IComposite.with_ports" href="#fnpcell.interfaces.IComposite.with_ports">with_ports</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICurve" href="#fnpcell.interfaces.ICurve">ICurve</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICurve.bundle" href="#fnpcell.interfaces.ICurve.bundle">bundle</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.c_mirrored" href="#fnpcell.interfaces.ICurve.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.curve_length" href="#fnpcell.interfaces.ICurve.curve_length">curve_length</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.curve_points" href="#fnpcell.interfaces.ICurve.curve_points">curve_points</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.end_orientations" href="#fnpcell.interfaces.ICurve.end_orientations">end_orientations</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.end_rays" href="#fnpcell.interfaces.ICurve.end_rays">end_rays</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.extended" href="#fnpcell.interfaces.ICurve.extended">extended</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.first_point" href="#fnpcell.interfaces.ICurve.first_point">first_point</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.h_mirrored" href="#fnpcell.interfaces.ICurve.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.last_point" href="#fnpcell.interfaces.ICurve.last_point">last_point</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.offsetted" href="#fnpcell.interfaces.ICurve.offsetted">offsetted</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.rail" href="#fnpcell.interfaces.ICurve.rail">rail</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.rotated" href="#fnpcell.interfaces.ICurve.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.sample_at" href="#fnpcell.interfaces.ICurve.sample_at">sample_at</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.scaled" href="#fnpcell.interfaces.ICurve.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.split_at" href="#fnpcell.interfaces.ICurve.split_at">split_at</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.subcurve" href="#fnpcell.interfaces.ICurve.subcurve">subcurve</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.to_shape" href="#fnpcell.interfaces.ICurve.to_shape">to_shape</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.transform" href="#fnpcell.interfaces.ICurve.transform">transform</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.translated" href="#fnpcell.interfaces.ICurve.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurve.v_mirrored" href="#fnpcell.interfaces.ICurve.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICurveLike" href="#fnpcell.interfaces.ICurveLike">ICurveLike</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.ICurveLike.curve_length" href="#fnpcell.interfaces.ICurveLike.curve_length">curve_length</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICurvePaint" href="#fnpcell.interfaces.ICurvePaint">ICurvePaint</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICurved" href="#fnpcell.interfaces.ICurved">ICurved</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICurved.c_mirrored" href="#fnpcell.interfaces.ICurved.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.curve" href="#fnpcell.interfaces.ICurved.curve">curve</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.h_mirrored" href="#fnpcell.interfaces.ICurved.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.raw_curve" href="#fnpcell.interfaces.ICurved.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.rotated" href="#fnpcell.interfaces.ICurved.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.scaled" href="#fnpcell.interfaces.ICurved.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.translated" href="#fnpcell.interfaces.ICurved.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurved.v_mirrored" href="#fnpcell.interfaces.ICurved.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICurvedCellRef" href="#fnpcell.interfaces.ICurvedCellRef">ICurvedCellRef</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.c_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.h_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.raw_curve" href="#fnpcell.interfaces.ICurvedCellRef.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.rotated" href="#fnpcell.interfaces.ICurvedCellRef.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.scaled" href="#fnpcell.interfaces.ICurvedCellRef.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.translated" href="#fnpcell.interfaces.ICurvedCellRef.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedCellRef.v_mirrored" href="#fnpcell.interfaces.ICurvedCellRef.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ICurvedElement" href="#fnpcell.interfaces.ICurvedElement">ICurvedElement</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ICurvedElement.c_mirrored" href="#fnpcell.interfaces.ICurvedElement.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedElement.h_mirrored" href="#fnpcell.interfaces.ICurvedElement.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedElement.raw_curve" href="#fnpcell.interfaces.ICurvedElement.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedElement.rotated" href="#fnpcell.interfaces.ICurvedElement.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedElement.scaled" href="#fnpcell.interfaces.ICurvedElement.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedElement.translated" href="#fnpcell.interfaces.ICurvedElement.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ICurvedElement.v_mirrored" href="#fnpcell.interfaces.ICurvedElement.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IElectronicMaterial" href="#fnpcell.interfaces.IElectronicMaterial">IElectronicMaterial</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IElectronicMaterial.name" href="#fnpcell.interfaces.IElectronicMaterial.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IElement" href="#fnpcell.interfaces.IElement">IElement</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IElement.c_mirrored" href="#fnpcell.interfaces.IElement.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IElement.h_mirrored" href="#fnpcell.interfaces.IElement.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IElement.rotated" href="#fnpcell.interfaces.IElement.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IElement.scaled" href="#fnpcell.interfaces.IElement.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IElement.transform" href="#fnpcell.interfaces.IElement.transform">transform</a></code></li>
<li><code><a title="fnpcell.interfaces.IElement.translated" href="#fnpcell.interfaces.IElement.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IElement.v_mirrored" href="#fnpcell.interfaces.IElement.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IFont" href="#fnpcell.interfaces.IFont">IFont</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IFont.ascender" href="#fnpcell.interfaces.IFont.ascender">ascender</a></code></li>
<li><code><a title="fnpcell.interfaces.IFont.descender" href="#fnpcell.interfaces.IFont.descender">descender</a></code></li>
<li><code><a title="fnpcell.interfaces.IFont.glyphs" href="#fnpcell.interfaces.IFont.glyphs">glyphs</a></code></li>
<li><code><a title="fnpcell.interfaces.IFont.name" href="#fnpcell.interfaces.IFont.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.IFont.units_per_em" href="#fnpcell.interfaces.IFont.units_per_em">units_per_em</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IGroup" href="#fnpcell.interfaces.IGroup">IGroup</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IGroup.c_mirrored" href="#fnpcell.interfaces.IGroup.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.content" href="#fnpcell.interfaces.IGroup.content">content</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.h_mirrored" href="#fnpcell.interfaces.IGroup.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.rotated" href="#fnpcell.interfaces.IGroup.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.scaled" href="#fnpcell.interfaces.IGroup.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.translated" href="#fnpcell.interfaces.IGroup.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.ungrouped" href="#fnpcell.interfaces.IGroup.ungrouped">ungrouped</a></code></li>
<li><code><a title="fnpcell.interfaces.IGroup.v_mirrored" href="#fnpcell.interfaces.IGroup.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILayer" href="#fnpcell.interfaces.ILayer">ILayer</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ILayer.description" href="#fnpcell.interfaces.ILayer.description">description</a></code></li>
<li><code><a title="fnpcell.interfaces.ILayer.name" href="#fnpcell.interfaces.ILayer.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.ILayer.order" href="#fnpcell.interfaces.ILayer.order">order</a></code></li>
<li><code><a title="fnpcell.interfaces.ILayer.process" href="#fnpcell.interfaces.ILayer.process">process</a></code></li>
<li><code><a title="fnpcell.interfaces.ILayer.purpose" href="#fnpcell.interfaces.ILayer.purpose">purpose</a></code></li>
<li><code><a title="fnpcell.interfaces.ILayer.value" href="#fnpcell.interfaces.ILayer.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILayered" href="#fnpcell.interfaces.ILayered">ILayered</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.ILayered.layer" href="#fnpcell.interfaces.ILayered.layer">layer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILibrary" href="#fnpcell.interfaces.ILibrary">ILibrary</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.ILibrary.content" href="#fnpcell.interfaces.ILibrary.content">content</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILink" href="#fnpcell.interfaces.ILink">ILink</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ILink.c_mirrored" href="#fnpcell.interfaces.ILink.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ILink.h_mirrored" href="#fnpcell.interfaces.ILink.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ILink.raw_curve" href="#fnpcell.interfaces.ILink.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.ILink.rotated" href="#fnpcell.interfaces.ILink.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ILink.scaled" href="#fnpcell.interfaces.ILink.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ILink.translated" href="#fnpcell.interfaces.ILink.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ILink.v_mirrored" href="#fnpcell.interfaces.ILink.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILinkBetween" href="#fnpcell.interfaces.ILinkBetween">ILinkBetween</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ILinkBetween.c_mirrored" href="#fnpcell.interfaces.ILinkBetween.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ILinkBetween.h_mirrored" href="#fnpcell.interfaces.ILinkBetween.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.ILinkBetween.raw_curve" href="#fnpcell.interfaces.ILinkBetween.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.ILinkBetween.rotated" href="#fnpcell.interfaces.ILinkBetween.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.ILinkBetween.scaled" href="#fnpcell.interfaces.ILinkBetween.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.ILinkBetween.translated" href="#fnpcell.interfaces.ILinkBetween.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.ILinkBetween.v_mirrored" href="#fnpcell.interfaces.ILinkBetween.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILinkType" href="#fnpcell.interfaces.ILinkType">ILinkType</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.ILinkType.port_width" href="#fnpcell.interfaces.ILinkType.port_width">port_width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ILinkingPolicy" href="#fnpcell.interfaces.ILinkingPolicy">ILinkingPolicy</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IMaterial" href="#fnpcell.interfaces.IMaterial">IMaterial</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IMaterial.name" href="#fnpcell.interfaces.IMaterial.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IMetalLineBetween" href="#fnpcell.interfaces.IMetalLineBetween">IMetalLineBetween</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.c_mirrored" href="#fnpcell.interfaces.IMetalLineBetween.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.end" href="#fnpcell.interfaces.IMetalLineBetween.end">end</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.h_mirrored" href="#fnpcell.interfaces.IMetalLineBetween.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.rotated" href="#fnpcell.interfaces.IMetalLineBetween.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.scaled" href="#fnpcell.interfaces.IMetalLineBetween.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.start" href="#fnpcell.interfaces.IMetalLineBetween.start">start</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.translated" href="#fnpcell.interfaces.IMetalLineBetween.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.v_mirrored" href="#fnpcell.interfaces.IMetalLineBetween.v_mirrored">v_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineBetween.with_environment" href="#fnpcell.interfaces.IMetalLineBetween.with_environment">with_environment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IMetalLineLike" href="#fnpcell.interfaces.IMetalLineLike">IMetalLineLike</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IMetalLineLike.c_mirrored" href="#fnpcell.interfaces.IMetalLineLike.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.curve_length" href="#fnpcell.interfaces.IMetalLineLike.curve_length">curve_length</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.h_mirrored" href="#fnpcell.interfaces.IMetalLineLike.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.raw_curve" href="#fnpcell.interfaces.IMetalLineLike.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.rotated" href="#fnpcell.interfaces.IMetalLineLike.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.scaled" href="#fnpcell.interfaces.IMetalLineLike.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.translated" href="#fnpcell.interfaces.IMetalLineLike.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineLike.v_mirrored" href="#fnpcell.interfaces.IMetalLineLike.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IMetalLineType" href="#fnpcell.interfaces.IMetalLineType">IMetalLineType</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IMetalLineType.is_class_isomorphic_to" href="#fnpcell.interfaces.IMetalLineType.is_class_isomorphic_to">is_class_isomorphic_to</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineType.is_isomorphic_to" href="#fnpcell.interfaces.IMetalLineType.is_isomorphic_to">is_isomorphic_to</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineType.metal_stack" href="#fnpcell.interfaces.IMetalLineType.metal_stack">metal_stack</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalLineType.port_names" href="#fnpcell.interfaces.IMetalLineType.port_names">port_names</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IMetalStack" href="#fnpcell.interfaces.IMetalStack">IMetalStack</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IMetalStack.connectivity" href="#fnpcell.interfaces.IMetalStack.connectivity">connectivity</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalStack.is_metal" href="#fnpcell.interfaces.IMetalStack.is_metal">is_metal</a></code></li>
<li><code><a title="fnpcell.interfaces.IMetalStack.layers" href="#fnpcell.interfaces.IMetalStack.layers">layers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IOwned" href="#fnpcell.interfaces.IOwned">IOwned</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IOwned.owner" href="#fnpcell.interfaces.IOwned.owner">owner</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IOwnedPin" href="#fnpcell.interfaces.IOwnedPin">IOwnedPin</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IOwnedPin.advanced" href="#fnpcell.interfaces.IOwnedPin.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.c_mirrored" href="#fnpcell.interfaces.IOwnedPin.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.h_mirrored" href="#fnpcell.interfaces.IOwnedPin.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.opposite" href="#fnpcell.interfaces.IOwnedPin.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.raw" href="#fnpcell.interfaces.IOwnedPin.raw">raw</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.repositioned" href="#fnpcell.interfaces.IOwnedPin.repositioned">repositioned</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.rotated" href="#fnpcell.interfaces.IOwnedPin.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPin.v_mirrored" href="#fnpcell.interfaces.IOwnedPin.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IOwnedPort" href="#fnpcell.interfaces.IOwnedPort">IOwnedPort</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IOwnedPort.advanced" href="#fnpcell.interfaces.IOwnedPort.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.c_mirrored" href="#fnpcell.interfaces.IOwnedPort.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.h_mirrored" href="#fnpcell.interfaces.IOwnedPort.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.opposite" href="#fnpcell.interfaces.IOwnedPort.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.raw" href="#fnpcell.interfaces.IOwnedPort.raw">raw</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.repositioned" href="#fnpcell.interfaces.IOwnedPort.repositioned">repositioned</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.rotated" href="#fnpcell.interfaces.IOwnedPort.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedPort.v_mirrored" href="#fnpcell.interfaces.IOwnedPort.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IOwnedTerminal" href="#fnpcell.interfaces.IOwnedTerminal">IOwnedTerminal</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.advanced" href="#fnpcell.interfaces.IOwnedTerminal.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.c_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.flatten" href="#fnpcell.interfaces.IOwnedTerminal.flatten">flatten</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.h_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.opposite" href="#fnpcell.interfaces.IOwnedTerminal.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.raw" href="#fnpcell.interfaces.IOwnedTerminal.raw">raw</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.repositioned" href="#fnpcell.interfaces.IOwnedTerminal.repositioned">repositioned</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.rotated" href="#fnpcell.interfaces.IOwnedTerminal.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.v_mirrored" href="#fnpcell.interfaces.IOwnedTerminal.v_mirrored">v_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IOwnedTerminal.with_name" href="#fnpcell.interfaces.IOwnedTerminal.with_name">with_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPhotonicMaterial" href="#fnpcell.interfaces.IPhotonicMaterial">IPhotonicMaterial</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IPhotonicMaterial.refractive_index" href="#fnpcell.interfaces.IPhotonicMaterial.refractive_index">refractive_index</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPin" href="#fnpcell.interfaces.IPin">IPin</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IPin.advanced" href="#fnpcell.interfaces.IPin.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.IPin.metal_line_type" href="#fnpcell.interfaces.IPin.metal_line_type">metal_line_type</a></code></li>
<li><code><a title="fnpcell.interfaces.IPin.opposite" href="#fnpcell.interfaces.IPin.opposite">opposite</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPolygon" href="#fnpcell.interfaces.IPolygon">IPolygon</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IPolygon.c_mirrored" href="#fnpcell.interfaces.IPolygon.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.h_mirrored" href="#fnpcell.interfaces.IPolygon.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.polygon_points" href="#fnpcell.interfaces.IPolygon.polygon_points">polygon_points</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.raw_shape" href="#fnpcell.interfaces.IPolygon.raw_shape">raw_shape</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.rotated" href="#fnpcell.interfaces.IPolygon.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.scaled" href="#fnpcell.interfaces.IPolygon.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.shape" href="#fnpcell.interfaces.IPolygon.shape">shape</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.translated" href="#fnpcell.interfaces.IPolygon.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygon.v_mirrored" href="#fnpcell.interfaces.IPolygon.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPolygonSet" href="#fnpcell.interfaces.IPolygonSet">IPolygonSet</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IPolygonSet.c_mirrored" href="#fnpcell.interfaces.IPolygonSet.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.h_mirrored" href="#fnpcell.interfaces.IPolygonSet.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.inverted" href="#fnpcell.interfaces.IPolygonSet.inverted">inverted</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.polygons" href="#fnpcell.interfaces.IPolygonSet.polygons">polygons</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.region" href="#fnpcell.interfaces.IPolygonSet.region">region</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.rotated" href="#fnpcell.interfaces.IPolygonSet.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.run" href="#fnpcell.interfaces.IPolygonSet.run">run</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.scaled" href="#fnpcell.interfaces.IPolygonSet.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.translated" href="#fnpcell.interfaces.IPolygonSet.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolygonSet.v_mirrored" href="#fnpcell.interfaces.IPolygonSet.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPolyline" href="#fnpcell.interfaces.IPolyline">IPolyline</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IPolyline.c_mirrored" href="#fnpcell.interfaces.IPolyline.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.curve_length" href="#fnpcell.interfaces.IPolyline.curve_length">curve_length</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.end_hints" href="#fnpcell.interfaces.IPolyline.end_hints">end_hints</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.end_rays" href="#fnpcell.interfaces.IPolyline.end_rays">end_rays</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.extension" href="#fnpcell.interfaces.IPolyline.extension">extension</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.final_stroke_offset" href="#fnpcell.interfaces.IPolyline.final_stroke_offset">final_stroke_offset</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.final_stroke_width" href="#fnpcell.interfaces.IPolyline.final_stroke_width">final_stroke_width</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.h_mirrored" href="#fnpcell.interfaces.IPolyline.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.miter_limit" href="#fnpcell.interfaces.IPolyline.miter_limit">miter_limit</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.polyline_points" href="#fnpcell.interfaces.IPolyline.polyline_points">polyline_points</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.rotated" href="#fnpcell.interfaces.IPolyline.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.scaled" href="#fnpcell.interfaces.IPolyline.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.stroke_offset" href="#fnpcell.interfaces.IPolyline.stroke_offset">stroke_offset</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.stroke_width" href="#fnpcell.interfaces.IPolyline.stroke_width">stroke_width</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.taper_function" href="#fnpcell.interfaces.IPolyline.taper_function">taper_function</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.translated" href="#fnpcell.interfaces.IPolyline.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPolyline.v_mirrored" href="#fnpcell.interfaces.IPolyline.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPort" href="#fnpcell.interfaces.IPort">IPort</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IPort.advanced" href="#fnpcell.interfaces.IPort.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.IPort.opposite" href="#fnpcell.interfaces.IPort.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.IPort.waveguide_type" href="#fnpcell.interfaces.IPort.waveguide_type">waveguide_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPositioned" href="#fnpcell.interfaces.IPositioned">IPositioned</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IPositioned.position" href="#fnpcell.interfaces.IPositioned.position">position</a></code></li>
<li><code><a title="fnpcell.interfaces.IPositioned.x" href="#fnpcell.interfaces.IPositioned.x">x</a></code></li>
<li><code><a title="fnpcell.interfaces.IPositioned.y" href="#fnpcell.interfaces.IPositioned.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPrimitive" href="#fnpcell.interfaces.IPrimitive">IPrimitive</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IPrimitive.c_mirrored" href="#fnpcell.interfaces.IPrimitive.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.h_mirrored" href="#fnpcell.interfaces.IPrimitive.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.layer" href="#fnpcell.interfaces.IPrimitive.layer">layer</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.rotated" href="#fnpcell.interfaces.IPrimitive.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.scaled" href="#fnpcell.interfaces.IPrimitive.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.translated" href="#fnpcell.interfaces.IPrimitive.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.v_mirrored" href="#fnpcell.interfaces.IPrimitive.v_mirrored">v_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IPrimitive.with_layer" href="#fnpcell.interfaces.IPrimitive.with_layer">with_layer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IProcess" href="#fnpcell.interfaces.IProcess">IProcess</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IProcess.description" href="#fnpcell.interfaces.IProcess.description">description</a></code></li>
<li><code><a title="fnpcell.interfaces.IProcess.name" href="#fnpcell.interfaces.IProcess.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.IProcess.order" href="#fnpcell.interfaces.IProcess.order">order</a></code></li>
<li><code><a title="fnpcell.interfaces.IProcess.value" href="#fnpcell.interfaces.IProcess.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IProcessor" href="#fnpcell.interfaces.IProcessor">IProcessor</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IProcessor.enter" href="#fnpcell.interfaces.IProcessor.enter">enter</a></code></li>
<li><code><a title="fnpcell.interfaces.IProcessor.exit" href="#fnpcell.interfaces.IProcessor.exit">exit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IPurpose" href="#fnpcell.interfaces.IPurpose">IPurpose</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IPurpose.description" href="#fnpcell.interfaces.IPurpose.description">description</a></code></li>
<li><code><a title="fnpcell.interfaces.IPurpose.name" href="#fnpcell.interfaces.IPurpose.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.IPurpose.order" href="#fnpcell.interfaces.IPurpose.order">order</a></code></li>
<li><code><a title="fnpcell.interfaces.IPurpose.value" href="#fnpcell.interfaces.IPurpose.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IRay" href="#fnpcell.interfaces.IRay">IRay</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IRay.advanced" href="#fnpcell.interfaces.IRay.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.IRay.opposite" href="#fnpcell.interfaces.IRay.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.IRay.orientation" href="#fnpcell.interfaces.IRay.orientation">orientation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IRegion" href="#fnpcell.interfaces.IRegion">IRegion</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IRegion.c_mirrored" href="#fnpcell.interfaces.IRegion.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.h_mirrored" href="#fnpcell.interfaces.IRegion.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.merged" href="#fnpcell.interfaces.IRegion.merged">merged</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.rotated" href="#fnpcell.interfaces.IRegion.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.scaled" href="#fnpcell.interfaces.IRegion.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.shapes" href="#fnpcell.interfaces.IRegion.shapes">shapes</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.translated" href="#fnpcell.interfaces.IRegion.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IRegion.v_mirrored" href="#fnpcell.interfaces.IRegion.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IRunnable" href="#fnpcell.interfaces.IRunnable">IRunnable</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IRunnable.run" href="#fnpcell.interfaces.IRunnable.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IRunnableContainer" href="#fnpcell.interfaces.IRunnableContainer">IRunnableContainer</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IRunnableContainer.content" href="#fnpcell.interfaces.IRunnableContainer.content">content</a></code></li>
<li><code><a title="fnpcell.interfaces.IRunnableContainer.run" href="#fnpcell.interfaces.IRunnableContainer.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IShape" href="#fnpcell.interfaces.IShape">IShape</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IShape.c_mirrored" href="#fnpcell.interfaces.IShape.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.h_mirrored" href="#fnpcell.interfaces.IShape.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.offsetted" href="#fnpcell.interfaces.IShape.offsetted">offsetted</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.rotated" href="#fnpcell.interfaces.IShape.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.scaled" href="#fnpcell.interfaces.IShape.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.shape_points" href="#fnpcell.interfaces.IShape.shape_points">shape_points</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.transform" href="#fnpcell.interfaces.IShape.transform">transform</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.translated" href="#fnpcell.interfaces.IShape.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IShape.v_mirrored" href="#fnpcell.interfaces.IShape.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IStraightWaveguideFactory" href="#fnpcell.interfaces.IStraightWaveguideFactory">IStraightWaveguideFactory</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ITaperCallable" href="#fnpcell.interfaces.ITaperCallable">ITaperCallable</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.ITerminal" href="#fnpcell.interfaces.ITerminal">ITerminal</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.ITerminal.advanced" href="#fnpcell.interfaces.ITerminal.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.annotation" href="#fnpcell.interfaces.ITerminal.annotation">annotation</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.disabled" href="#fnpcell.interfaces.ITerminal.disabled">disabled</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.hidden" href="#fnpcell.interfaces.ITerminal.hidden">hidden</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.matches" href="#fnpcell.interfaces.ITerminal.matches">matches</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.name" href="#fnpcell.interfaces.ITerminal.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.opposite" href="#fnpcell.interfaces.ITerminal.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.orientation" href="#fnpcell.interfaces.ITerminal.orientation">orientation</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.run" href="#fnpcell.interfaces.ITerminal.run">run</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.shape" href="#fnpcell.interfaces.ITerminal.shape">shape</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.with_name" href="#fnpcell.interfaces.ITerminal.with_name">with_name</a></code></li>
<li><code><a title="fnpcell.interfaces.ITerminal.with_orientation" href="#fnpcell.interfaces.ITerminal.with_orientation">with_orientation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IUpdatable" href="#fnpcell.interfaces.IUpdatable">IUpdatable</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IUpdatable.updated" href="#fnpcell.interfaces.IUpdatable.updated">updated</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IViasFactory" href="#fnpcell.interfaces.IViasFactory">IViasFactory</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IWaveguideBetween" href="#fnpcell.interfaces.IWaveguideBetween">IWaveguideBetween</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.c_mirrored" href="#fnpcell.interfaces.IWaveguideBetween.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.end" href="#fnpcell.interfaces.IWaveguideBetween.end">end</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.h_mirrored" href="#fnpcell.interfaces.IWaveguideBetween.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.rotated" href="#fnpcell.interfaces.IWaveguideBetween.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.scaled" href="#fnpcell.interfaces.IWaveguideBetween.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.start" href="#fnpcell.interfaces.IWaveguideBetween.start">start</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.translated" href="#fnpcell.interfaces.IWaveguideBetween.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.v_mirrored" href="#fnpcell.interfaces.IWaveguideBetween.v_mirrored">v_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideBetween.with_environment" href="#fnpcell.interfaces.IWaveguideBetween.with_environment">with_environment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IWaveguideLike" href="#fnpcell.interfaces.IWaveguideLike">IWaveguideLike</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.IWaveguideLike.c_mirrored" href="#fnpcell.interfaces.IWaveguideLike.c_mirrored">c_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.curve_length" href="#fnpcell.interfaces.IWaveguideLike.curve_length">curve_length</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.h_mirrored" href="#fnpcell.interfaces.IWaveguideLike.h_mirrored">h_mirrored</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.raw_curve" href="#fnpcell.interfaces.IWaveguideLike.raw_curve">raw_curve</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.rotated" href="#fnpcell.interfaces.IWaveguideLike.rotated">rotated</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.scaled" href="#fnpcell.interfaces.IWaveguideLike.scaled">scaled</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.translated" href="#fnpcell.interfaces.IWaveguideLike.translated">translated</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideLike.v_mirrored" href="#fnpcell.interfaces.IWaveguideLike.v_mirrored">v_mirrored</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.IWaveguideType" href="#fnpcell.interfaces.IWaveguideType">IWaveguideType</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.IWaveguideType.band" href="#fnpcell.interfaces.IWaveguideType.band">band</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideType.bend_factory" href="#fnpcell.interfaces.IWaveguideType.bend_factory">bend_factory</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideType.is_class_isomorphic_to" href="#fnpcell.interfaces.IWaveguideType.is_class_isomorphic_to">is_class_isomorphic_to</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideType.is_isomorphic_to" href="#fnpcell.interfaces.IWaveguideType.is_isomorphic_to">is_isomorphic_to</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideType.port_names" href="#fnpcell.interfaces.IWaveguideType.port_names">port_names</a></code></li>
<li><code><a title="fnpcell.interfaces.IWaveguideType.straight_factory" href="#fnpcell.interfaces.IWaveguideType.straight_factory">straight_factory</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Offset" href="#fnpcell.interfaces.Offset">Offset</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.Offset.from_end" href="#fnpcell.interfaces.Offset.from_end">from_end</a></code></li>
<li><code><a title="fnpcell.interfaces.Offset.from_start" href="#fnpcell.interfaces.Offset.from_start">from_start</a></code></li>
<li><code><a title="fnpcell.interfaces.Offset.relative_to" href="#fnpcell.interfaces.Offset.relative_to">relative_to</a></code></li>
<li><code><a title="fnpcell.interfaces.Offset.until_x" href="#fnpcell.interfaces.Offset.until_x">until_x</a></code></li>
<li><code><a title="fnpcell.interfaces.Offset.until_y" href="#fnpcell.interfaces.Offset.until_y">until_y</a></code></li>
<li><code><a title="fnpcell.interfaces.Offset.x" href="#fnpcell.interfaces.Offset.x">x</a></code></li>
<li><code><a title="fnpcell.interfaces.Offset.y" href="#fnpcell.interfaces.Offset.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Ray" href="#fnpcell.interfaces.Ray">Ray</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.Ray.advanced" href="#fnpcell.interfaces.Ray.advanced">advanced</a></code></li>
<li><code><a title="fnpcell.interfaces.Ray.opposite" href="#fnpcell.interfaces.Ray.opposite">opposite</a></code></li>
<li><code><a title="fnpcell.interfaces.Ray.orientation" href="#fnpcell.interfaces.Ray.orientation">orientation</a></code></li>
<li><code><a title="fnpcell.interfaces.Ray.position" href="#fnpcell.interfaces.Ray.position">position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.RelativeTo" href="#fnpcell.interfaces.RelativeTo">RelativeTo</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.RelativeTo.END" href="#fnpcell.interfaces.RelativeTo.END">END</a></code></li>
<li><code><a title="fnpcell.interfaces.RelativeTo.PREV" href="#fnpcell.interfaces.RelativeTo.PREV">PREV</a></code></li>
<li><code><a title="fnpcell.interfaces.RelativeTo.START" href="#fnpcell.interfaces.RelativeTo.START">START</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.SampleInfo" href="#fnpcell.interfaces.SampleInfo">SampleInfo</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.SampleInfo.length" href="#fnpcell.interfaces.SampleInfo.length">length</a></code></li>
<li><code><a title="fnpcell.interfaces.SampleInfo.orientation" href="#fnpcell.interfaces.SampleInfo.orientation">orientation</a></code></li>
<li><code><a title="fnpcell.interfaces.SampleInfo.position" href="#fnpcell.interfaces.SampleInfo.position">position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.TaperFunction" href="#fnpcell.interfaces.TaperFunction">TaperFunction</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.TaperFunction.LINEAR" href="#fnpcell.interfaces.TaperFunction.LINEAR">LINEAR</a></code></li>
<li><code><a title="fnpcell.interfaces.TaperFunction.PARABOLIC" href="#fnpcell.interfaces.TaperFunction.PARABOLIC">PARABOLIC</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.TaperFunctionLinear" href="#fnpcell.interfaces.TaperFunctionLinear">TaperFunctionLinear</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.TaperFunctionParabolic" href="#fnpcell.interfaces.TaperFunctionParabolic">TaperFunctionParabolic</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.TextBaseline" href="#fnpcell.interfaces.TextBaseline">TextBaseline</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.TextBaseline.ALPHABETIC" href="#fnpcell.interfaces.TextBaseline.ALPHABETIC">ALPHABETIC</a></code></li>
<li><code><a title="fnpcell.interfaces.TextBaseline.BOTTOM" href="#fnpcell.interfaces.TextBaseline.BOTTOM">BOTTOM</a></code></li>
<li><code><a title="fnpcell.interfaces.TextBaseline.TOP" href="#fnpcell.interfaces.TextBaseline.TOP">TOP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Type2TypeMeta" href="#fnpcell.interfaces.Type2TypeMeta">Type2TypeMeta</a></code></h4>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Unimplemented" href="#fnpcell.interfaces.Unimplemented">Unimplemented</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.Unimplemented.message" href="#fnpcell.interfaces.Unimplemented.message">message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.UnknownLayer" href="#fnpcell.interfaces.UnknownLayer">UnknownLayer</a></code></h4>
<ul class="two-column">
<li><code><a title="fnpcell.interfaces.UnknownLayer.description" href="#fnpcell.interfaces.UnknownLayer.description">description</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownLayer.name" href="#fnpcell.interfaces.UnknownLayer.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownLayer.name_template" href="#fnpcell.interfaces.UnknownLayer.name_template">name_template</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownLayer.order" href="#fnpcell.interfaces.UnknownLayer.order">order</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownLayer.process" href="#fnpcell.interfaces.UnknownLayer.process">process</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownLayer.purpose" href="#fnpcell.interfaces.UnknownLayer.purpose">purpose</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownLayer.value" href="#fnpcell.interfaces.UnknownLayer.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.UnknownProcess" href="#fnpcell.interfaces.UnknownProcess">UnknownProcess</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.UnknownProcess.description" href="#fnpcell.interfaces.UnknownProcess.description">description</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownProcess.name" href="#fnpcell.interfaces.UnknownProcess.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownProcess.name_template" href="#fnpcell.interfaces.UnknownProcess.name_template">name_template</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownProcess.order" href="#fnpcell.interfaces.UnknownProcess.order">order</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownProcess.value" href="#fnpcell.interfaces.UnknownProcess.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.UnknownPurpose" href="#fnpcell.interfaces.UnknownPurpose">UnknownPurpose</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.UnknownPurpose.description" href="#fnpcell.interfaces.UnknownPurpose.description">description</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownPurpose.name" href="#fnpcell.interfaces.UnknownPurpose.name">name</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownPurpose.name_template" href="#fnpcell.interfaces.UnknownPurpose.name_template">name_template</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownPurpose.order" href="#fnpcell.interfaces.UnknownPurpose.order">order</a></code></li>
<li><code><a title="fnpcell.interfaces.UnknownPurpose.value" href="#fnpcell.interfaces.UnknownPurpose.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.VertialAlign" href="#fnpcell.interfaces.VertialAlign">VertialAlign</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.VertialAlign.BOTTOM" href="#fnpcell.interfaces.VertialAlign.BOTTOM">BOTTOM</a></code></li>
<li><code><a title="fnpcell.interfaces.VertialAlign.MIDDLE" href="#fnpcell.interfaces.VertialAlign.MIDDLE">MIDDLE</a></code></li>
<li><code><a title="fnpcell.interfaces.VertialAlign.TOP" href="#fnpcell.interfaces.VertialAlign.TOP">TOP</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fnpcell.interfaces.Waypoints" href="#fnpcell.interfaces.Waypoints">Waypoints</a></code></h4>
<ul class="">
<li><code><a title="fnpcell.interfaces.Waypoints.end" href="#fnpcell.interfaces.Waypoints.end">end</a></code></li>
<li><code><a title="fnpcell.interfaces.Waypoints.middle" href="#fnpcell.interfaces.Waypoints.middle">middle</a></code></li>
<li><code><a title="fnpcell.interfaces.Waypoints.start" href="#fnpcell.interfaces.Waypoints.start">start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
</footer>
</body>
</html>